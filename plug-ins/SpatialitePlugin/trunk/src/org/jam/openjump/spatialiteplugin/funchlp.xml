<?xml version="1.0" encoding="UTF-8"?>
<ROOT>
<GROUP caption="Tables" code="">
<DES>DB tables</DES>
</GROUP>
<GROUP caption="All SpatiaLite v4.2.1 Functions" code="">
<DES><![CDATA[All SQL functions supported by SpatiaLite v4.2.1<br>
in the same order than in the SpatiaLite web page]]></DES>
<GROUP caption="1- Version Info" code="">
<DES>SQL Version Info [and build options testing] functions</DES>
<FUNC caption="spatialite_version" code="spatialite_version()">
 <DES><![CDATA[<h4>spatialite_version( <i>void</i> ) : <i>String</i></h4><br>
Returns the current SpatiaLite version as a text string. ]]></DES>
</FUNC>

<FUNC caption="spatialite_target_cpu" code="spatialite_target_cpu()">
 <DES><![CDATA[<h4>spatialite_target_cpu( <i>void</i> ) : <i>String</i></h4><br>
Returns the current SpatiaLite Target CPU as a text string. ]]></DES>
</FUNC>

<FUNC caption="proj4_version" code="proj4_version()">
 <DES><![CDATA[<h4>proj4_version( <i>void</i> ) : <i>String</i></h4><br>
Returns the current PROJ.4 version as a text string or <br>NULL if PROJ.4 is currently unsupported. ]]></DES>
</FUNC>

<FUNC caption="geos_version" code="geos_version()">
 <DES><![CDATA[<h4>geos_version( <i>void</i> ) : <i>String</i></h4><br>
Returns the current GEOS version as a text string or <br>NULL if GEOS is currently unsupported. ]]></DES>
</FUNC>

<FUNC caption="lwgeom_version" code="lwgeom_version()">
 <DES><![CDATA[<h4>lwgeom_version( <i>void</i> ) : <i>String</i></h4><br>
Returns the current LWGEOM version as a text string or <br>NULL if LWGEOM is currently unsupported. ]]></DES>
</FUNC>

<FUNC caption="libxml2_version" code="libxml2_version()">
 <DES><![CDATA[<h4>libxml2_version( <i>void</i> ) : <i>String</i></h4><br>
Returns the current LibXML2 version as a text string or <br>NULL if LibXML2 is currently unsupported. ]]></DES>
</FUNC>

<FUNC caption="HasIconv" code="HasIconv()">
 <DES><![CDATA[<h4>HasIconv( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling ICONV. ]]></DES>
</FUNC>

<FUNC caption="HasMathSQL" code="HasMathSQL()">
 <DES><![CDATA[<h4>HasMathSQL( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling MATHSQL. ]]></DES>
</FUNC>

<FUNC caption="HasGeoCallbacks" code="HasGeoCallbacks()">
 <DES><![CDATA[<h4>HasGeoCallbacks( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling GEOCALLBACKS. ]]></DES>
</FUNC>

<FUNC caption="HasProj" code="HasProj()">
 <DES><![CDATA[<h4>HasProj( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling PROJ. ]]></DES>
</FUNC>

<FUNC caption="HasGeos" code="HasGeos()">
 <DES><![CDATA[<h4>HasGeos( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling GEOS. ]]></DES>
</FUNC>

<FUNC caption="HasGeosAdvanced" code="HasGeosAdvanced()">
 <DES><![CDATA[<h4>HasGeosAdvanced( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling GEOSADVANCED. ]]></DES>
</FUNC>

<FUNC caption="HasGeosTrunk" code="HasGeosTrunk()">
 <DES><![CDATA[<h4>HasGeosTrunk( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling GEOSTRUNK. ]]></DES>
</FUNC>

<FUNC caption="HasLwGeom" code="HasLwGeom()">
 <DES><![CDATA[<h4>HasLwGeom( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling LWGEOM. ]]></DES>
</FUNC>

<FUNC caption="HasLibXML2" code="HasLibXML2()">
 <DES><![CDATA[<h4>HasLibXML2( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling LibXML2. ]]></DES>
</FUNC>

<FUNC caption="HasEpsg" code="HasEpsg()">
 <DES><![CDATA[<h4>HasEpsg( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling EPSG. ]]></DES>
</FUNC>

<FUNC caption="HasFreeXL" code="HasFreeXL()">
 <DES><![CDATA[<h4>HasFreeXL( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built enabling FREEXL. ]]></DES>
</FUNC>

<FUNC caption="HasGeoPackage" code="HasGeoPackage()">
 <DES><![CDATA[<h4>HasGeoPackage( <i>void</i> ) : <i>Boolean</i></h4><br>
TRUE if the underlaying library was built <br>enabling GeoPackage support (GPKG). ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="2- Generic SQL utilities" code="">
<DES>Generic SQL utility functions</DES>
<FUNC caption="CastToInteger" code="CastToInteger()">
 <DES><![CDATA[<h4>CastToInteger( value <i>Generic</i> ) : <i>Integer</i></h4><br>
Returns the intput value possibly casted to the Integer data-type. <br>NULL if no conversion is possible. ]]></DES>
</FUNC>

<FUNC caption="CastToDouble" code="CastToDouble()">
 <DES><![CDATA[<h4>CastToDouble( value <i>Generic</i> ) : <i>Double precision</i></h4><br>
Returns the intput value possibly casted to the Double data-type. <br>NULL if no conversion is possible. ]]></DES>
</FUNC>

<FUNC caption="CastToText" code="CastToText()">
 <DES><![CDATA[<h4>CastToText( value <i>Generic</i> ) : <i>Text</i>   <br>
 CastTo<i>Text</i>( value <i>Generic</i> , zero_pad <i>Integer</i> ) : <i>Text</i></h4><br>
Returns the input value possibly casted to the Text data-type. <br>
 NULL if no conversion is possible. If an optional argument <b>zero_pad</b> <br>
 is passed and the input value is of the <b>Integer</b> or <b>Double</b> type, <br>
 then the returned string will be padded using as much trailing ZEROs <br>
 so to ensure the required length. ]]></DES>
</FUNC>

<FUNC caption="CastToBlob" code="CastToBlob()">
 <DES><![CDATA[<h4>CastTo<i>BLOB</i>( value <i>Generic</i> ) : <i>BLOB</i>  <br>
CastTo<i>BLOB</i>( value <i>Generic</i> , hex_input <i>Boolean</i> ) : <i>BLOB</i></h4><br>
Returns the intput value possibly casted to the BLOB data-type. <br>
 if the optional argument hex_input is set to TRUE the input value will <br>
 be expected to correspond to an HexaDecimal string, e.g. <b>01ab89EF</b>; <br>
 if this assumption fails then NULL will be returned.   <br>
 NULL if no conversion is possible. ]]></DES>
</FUNC>

<FUNC caption="ForceAsNull" code="ForceAsNull()">
 <DES><![CDATA[<h4>ForceAsNull( val1 <i>Generic</i> , val2 <i>Generic</i>) : <i>Generic</i></h4><br>
If val1 and val2 are equal (and exactly of the same data-type) NULL will be returned.; <br>
 Otherwise val1 will be returned absolutely untouched and still <br>
 preserving its original data-type. ]]></DES>
</FUNC>

<FUNC caption="CreateUUID" code="CreateUUID()">
 <DES><![CDATA[<h4>CreateUUID( <i>void</i> ) : <i>Text</i></h4><br>
Returns a Version 4 (random) UUID (Universally unique identifier). ]]></DES>
</FUNC>

<FUNC caption="MD5Checksum" code="MD5Checksum()">
 <DES><![CDATA[<h4>MD5Checksum( <i>BLOB</i> | <i>Text</i> ) : <i>Text</i></h4><br>
Returns the MD5 checksum corresponding to the input value. <br>
 Will return NULL for non-BLOB or non-TEXT input. ]]></DES>
</FUNC>

<FUNC caption="MD5TotalChecksum" code="MD5TotalChecksum()">
 <DES><![CDATA[<h4>MD5TotalChecksum( <i>BLOB</i> | <i>Text</i> ) : <i>Text</i></h4><br>
Returns a cumulative MD5 checksum. <br>
 Aggregate function. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="3 -SQL math functions" code="">
<DES>SQL math functions</DES>
<FUNC caption="Abs" code="Abs()">
 <DES><![CDATA[<h4>Abs( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the absolute value of x. ]]></DES>
</FUNC>

<FUNC caption="Acos" code="Acos()">
 <DES><![CDATA[<h4>Acos( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the arc cosine of x, that is, the value whose cosine is x. <br>
 Returns NULL if x is not in the range -1 to 1. ]]></DES>
</FUNC>

<FUNC caption="Asin" code="Asin()">
 <DES><![CDATA[<h4>Asin( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the arc sine of x, that is, the value whose sine is x. <br>
 Returns NULL if x is not in the range -1 to 1. ]]></DES>
</FUNC>

<FUNC caption="Atan" code="Atan()">
 <DES><![CDATA[<h4>Atan( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the arc tangent of x, that is, the value whose tangent is x. ]]></DES>
</FUNC>

<FUNC caption="Ceiling" code="Ceiling()">
 <DES><![CDATA[<h4>Ceiling( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the smallest integer value not less than x. ]]></DES>
</FUNC>

<FUNC caption="Cos" code="Cos()">
 <DES><![CDATA[<h4>Cos( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the cosine of x, where x is given in radians. ]]></DES>
</FUNC>

<FUNC caption="Cot" code="Cot()">
 <DES><![CDATA[<h4>Cot( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the cotangent of x, where x is given in radians. ]]></DES>
</FUNC>

<FUNC caption="Degrees" code="Degrees()">
 <DES><![CDATA[<h4>Degrees( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the argument x, converted from radians to degrees. ]]></DES>
</FUNC>

<FUNC caption="Exp" code="Exp()">
 <DES><![CDATA[<h4>Exp( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the value of <i>e</i> (the base of natural logarithms) <br>
 raised to the power of x.   The inverse of this function is Log() <br>
 (using a single argument only) or Ln(). ]]></DES>
</FUNC>

<FUNC caption="Floor" code="Floor()">
 <DES><![CDATA[<h4>Floor( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the largest integer value not greater than x. ]]></DES>
</FUNC>

<FUNC caption="Ln" code="Ln()">
 <DES><![CDATA[<h4>Ln( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the natural logarithm of x.<br>
 That is, the base-<i>e</i> logarithm of x If x is less than or equal to 0, <br>
 then NULL is returned. ]]></DES>
</FUNC>

<FUNC caption="Log" code="Log()">
 <DES><![CDATA[<h4>Log( b <i>Double precision</i> , x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the logarithm of x to the base b. <br>
 If x is less than or equal to 0, or if b is less than or equal to 1, <br>
 then NULL is returned.   <br>
 Log(b, x) is equivalent to Log(x) / Log(b). ]]></DES>
</FUNC>

<FUNC caption="Log2" code="Log2()">
 <DES><![CDATA[<h4>Log2( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the base-2 logarithm of x.   <br>
 Log2(x) is equivalent to Log(x) / Log(2). ]]></DES>
</FUNC>

<FUNC caption="Log10" code="Log10()">
 <DES><![CDATA[<h4>Log10( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the base-10 logarithm of x.   <br>
 Log10(x) is equivalent to Log(x) / Log(10). ]]></DES>
</FUNC>

<FUNC caption="PI" code="PI()">
 <DES><![CDATA[<h4>PI( <i>void</i> ) : <i>Double precision</i></h4><br>
Returns the value of PI. ]]></DES>
</FUNC>

<FUNC caption="Power" code="Power()">
 <DES><![CDATA[<h4>Power( x <i>Double precision</i> , y <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the value of x raised to the power of y. ]]></DES>
</FUNC>

<FUNC caption="Radians" code="Radians()">
 <DES><![CDATA[<h4>Radians( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the argument x, converted from degrees to radians. ]]></DES>
</FUNC>

<FUNC caption="Sign" code="Sign()">
 <DES><![CDATA[<h4>Sign( x <i>Double precision</i> ) : <i>Integer</i></h4><br>
Returns the sign of the argument as -1, 0, or 1, <br>
 depending on whether x is negative, zero, or positive. ]]></DES>
</FUNC>

<FUNC caption="Sin" code="Sin()">
 <DES><![CDATA[<h4>Sin( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the sine of x, where x is given in radians. ]]></DES>
</FUNC>

<FUNC caption="Sqrt" code="Sqrt()">
 <DES><![CDATA[<h4>Sqrt( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the square root of a non-negative number x. ]]></DES>
</FUNC>

<FUNC caption="Stddev_pop" code="Stddev_pop()">
 <DES><![CDATA[<h4>Stddev_pop( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the population standard deviation of the input values. <br>
 Aggregate function. ]]></DES>
</FUNC>

<FUNC caption="Stddev_samp" code="Stddev_samp()">
 <DES><![CDATA[<h4>Stddev_samp( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the sample standard deviation of the input values. <br>
 Aggregate function. ]]></DES>
</FUNC>

<FUNC caption="Tan" code="Tan()">
 <DES><![CDATA[<h4>Tan( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the tangent of x, where x is given in radians. ]]></DES>
</FUNC>

<FUNC caption="Var_pop" code="Var_pop()">
 <DES><![CDATA[<h4>Var_pop( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the population variance of the input values <br>
 (square of the population standard deviation). <br>
 Aggregate function. ]]></DES>
</FUNC>

<FUNC caption="Var_samp" code="Var_samp()">
 <DES><![CDATA[<h4>Var_samp( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
Returns the sample variance of the input values <br>
 (square of the sample standard deviation). <br>
 Aggregate function. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="4- GEOS/LWGEOM messages" code="">
<DES>SQL functions reporting GEOS / LWGEOM errors and warnings</DES>

<FUNC caption="GEOS_GetLastWarningMsg" code="GEOS_GetLastWarningMsg()">
 <DES><![CDATA[<h4>GEOS_GetLastWarningMsg( <i>void</i> ) : <i>String</i></h4><br>
Will return the most recent warning message returned by GEOS (if any).   <br>
 NULL will be returned if there is no pending GEOS warning. ]]></DES>
</FUNC>

<FUNC caption="GEOS_GetLastErrorMsg" code="GEOS_GetLastErrorMsg()">
 <DES><![CDATA[<h4>GEOS_GetLastErrorMsg( <i>void</i> ) : <i>String</i></h4><br>
Will return the most recent error message returned by GEOS (if any).   <br>
 NULL will be returned if there is no pending GEOS error. ]]></DES>
</FUNC>

<FUNC caption="GEOS_GetLastAuxErrorMsg" code="GEOS_GetLastAuxErrorMsg()">
 <DES><![CDATA[<h4>GEOS_GetLastAuxErrorMsg( <i>void</i> ) : <i>String</i></h4><br>
Will return the most recent error message (auxiliary) returned by GEOS (if any).   <br>
 NULL will be returned if there is no pending GEOS (auxiliary) error. ]]></DES>
</FUNC>

<FUNC caption="GEOS_GetCriticalPointFromMsg" code="GEOS_GetCriticalPointFromMsg()">
 <DES><![CDATA[<h4>GEOS_GetCriticalPointFromMsg( <i>void</i> ) : <i>Point</i>   <br>
 GEOS_GetCriticalPointFromMsg( SRID <i>Integer</i> ) : <i>Point</i></h4><br>
Will (possibly) return a Point Geometry extracted from the latest error / <br>
warning message returned by GEOS.   <br>
 NULL will be returned if there is no pending GEOS message, or if the current GEOS <br>
 message doesn't contain a critical Point. ]]></DES>
</FUNC>

<FUNC caption="LWGEOM_GetLastWarningMsg" code="LWGEOM_GetLastWarningMsg()">
 <DES><![CDATA[<h4>LWGEOM_GetLastWarningMsg( <i>void</i> ) : <i>String</i></h4><br>
Will return the most recent warning message returned by LWGEOM (if any).   <br>
 NULL will be returned if there is no pending LWGEOM warning. ]]></DES>
</FUNC>

<FUNC caption="LWGEOM_GetLastErrorMsg" code="LWGEOM_GetLastErrorMsg()">
 <DES><![CDATA[<h4>LWGEOM_GetLastErrorMsg( <i>void</i> ) : <i>String</i></h4><br>
Will return the most recent error message returned by LWGEOM (if any).   <br>
 NULL will be returned if there is no pending LWGEOM error. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="5- Unit conversions" code="">
	<DES>SQL length/distance unit-conversion functions</DES>

<FUNC caption="Kilometer" code="CvtToKm()">
 <DES><![CDATA[<h4>CvtToKm( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromKm( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / kilometers ]]></DES>
</FUNC>

<FUNC caption="Decimeter" code="CvtToDm()">
 <DES><![CDATA[<h4>CvtToDm( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromDm( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / decimeters ]]></DES>
</FUNC>

<FUNC caption="Centimeter" code="CvtToCm()">
 <DES><![CDATA[<h4>CvtToCm( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromCm( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / centimeters ]]></DES>
</FUNC>

<FUNC caption="Millimeter" code="CvtToMm()">
 <DES><![CDATA[<h4>CvtToMm( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromMm( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / millimeters ]]></DES>
</FUNC>

<FUNC caption="International Nautical Mile" code="CvtToKmi()">
 <DES><![CDATA[<h4>CvtToKmi( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromKmi( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / international nautical miles ]]></DES>
</FUNC>

<FUNC caption="International Inch" code="CvtToIn()">
 <DES><![CDATA[<h4>CvtToIn( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromIn( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / international inches ]]></DES>
</FUNC>

<FUNC caption="International Foot" code="CvtToFt()">
 <DES><![CDATA[<h4>CvtToFt( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromFt( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / international feet ]]></DES>
</FUNC>

<FUNC caption="International Yard" code="CvtToYd()">
 <DES><![CDATA[<h4>CvtToYd( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromYd( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / international yards ]]></DES>
</FUNC>

<FUNC caption="International Statute Mile" code="CvtToMi()">
 <DES><![CDATA[<h4>CvtToMi( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromMi( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / international statute miles ]]></DES>
</FUNC>

<FUNC caption="International Fathom" code="CvtToFath()">
 <DES><![CDATA[<h4>CvtToFath( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromFath( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / international fathoms ]]></DES>
</FUNC>

<FUNC caption="International Chain" code="CvtToCh()">
 <DES><![CDATA[<h4>CvtToCh( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromCh( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / international chains ]]></DES>
</FUNC>

<FUNC caption="International Link" code="CvtToLink()">
 <DES><![CDATA[<h4>CvtToLink( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromLink( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / international links ]]></DES>
</FUNC>

<FUNC caption="U.S. Inch" code="CvtToUsIn()">
 <DES><![CDATA[<h4>CvtToUsIn( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromUsIn( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / U.S. inches ]]></DES>
</FUNC>

<FUNC caption="U.S. Foot" code="CvtToUsFt()">
 <DES><![CDATA[<h4>CvtToUsFt( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromUsFt( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / U.S. feet ]]></DES>
</FUNC>

<FUNC caption="U.S. Yard" code="CvtToUsYd()">
 <DES><![CDATA[<h4>CvtToUsYd( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromUsYd( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / U.S. yards ]]></DES>
</FUNC>

<FUNC caption="U.S. Statute Mile" code="CvtToUsMi()">
 <DES><![CDATA[<h4>CvtToUsMi( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromUsMi( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / U.S. statute miles ]]></DES>
</FUNC>

<FUNC caption="U.S. Chain" code="CvtToUsCh()">
 <DES><![CDATA[<h4>CvtToUsCh( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromUsCh( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / U.S. chains ]]></DES>
</FUNC>

<FUNC caption="Indian Foot" code="CvtToIndFt()">
 <DES><![CDATA[<h4>CvtToIndFt( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromIndFt( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / indian feet ]]></DES>
</FUNC>

<FUNC caption="Indian Yard" code="CvtToIndYd()">
 <DES><![CDATA[<h4>CvtToIndYd( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromIndYd( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / indian yards ]]></DES>
</FUNC>

<FUNC caption="Indian Chain" code="CvtToIndCh()">
 <DES><![CDATA[<h4>CvtToIndCh( x <i>Double precision</i> ) : <i>Double precision</i>   <br>
 CvtFromIndCh( x <i>Double precision</i> ) : <i>Double precision</i></h4><br>
meters / indian chains ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="6- SQL for DD/DMS" code="">
<DES>SQL conversion functions from DD/DMS notations (longitude/latitude)</DES>
<FUNC caption="DD to DMS" code="LongLatToDMS()">
 <DES><![CDATA[<h4>LongLatToDMS( longitude <i>Double precision</i> , latitude <i>Double precision</i> ) : <i>String</i></h4><br>
Returns a DMS string (Degrees, Minutes and Seconds) starting from DD <br>
 (Decimal Degrees) input coordinates.   NULL will be returned on invalid input. ]]></DES>
</FUNC>

<FUNC caption="DMS to DD" code="LongitudeFromDMS()">
 <DES><![CDATA[<h4>LongitudeFromDMS( dms_expression <i>String</i> ) : <i>Double precision</i>   <br>
 LatitudeFromDMS( dms_expression <i>String</i> ) : <i>Double precision</i></h4><br>
Returns the DD coordinates from within a DMS expression.   <br>
 NULL will be returned on invalid input. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="7- SQL for BLOBs" code="">
<DES>SQL utility functions for BLOB objects</DES>
<FUNC caption="IsZipBlob" code="IsZipBlob()">
 <DES><![CDATA[<h4>IsZipBlob( content <i>BLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL or not-BLOB argument.   <br>
 TRUE if this BLOB object corresponds to a valid ZIP-compressed file. ]]></DES>
</FUNC>

<FUNC caption="IsPdfBlob" code="IsPdfBlob()">
 <DES><![CDATA[<h4>IsPdfBlob( content <i>BLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL or not-BLOB argument.   <br>
 TRUE if this BLOB object corresponds to a valid PDF document. ]]></DES>
</FUNC>

<FUNC caption="IsGifBlob" code="IsGifBlob()">
 <DES><![CDATA[<h4>IsGifBlob( image <i>BLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL or not-BLOB argument.   <br>
 TRUE if this BLOB object corresponds to a valid GIF image. ]]></DES>
</FUNC>

<FUNC caption="IsPngBlob" code="IsPngBlob()">
 <DES><![CDATA[<h4>IsPngBlob( image <i>BLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL or not-BLOB argument.   <br>
 TRUE if this BLOB object corresponds to a valid PNG image. ]]></DES>
</FUNC>

<FUNC caption="IsTiffBlob" code="IsTiffBlob()">
 <DES><![CDATA[<h4>IsTiffBlob( image <i>BLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL or not-BLOB argument.   <br>
 TRUE if this BLOB object corresponds to a valid TIFF image. ]]></DES>
</FUNC>

<FUNC caption="IsJpegBlob" code="IsJpegBlob()">
 <DES><![CDATA[<h4>IsJpegBlob( image <i>BLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL or not-BLOB argument.   <br>
 TRUE if this BLOB object corresponds to a valid JPEG image. ]]></DES>
</FUNC>

<FUNC caption="IsExifBlob" code="IsExifBlob()">
 <DES><![CDATA[<h4>IsExifBlob( image <i>BLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL or not-BLOB argument.   <br>
 TRUE if this BLOB object corresponds to a valid EXIF image. <br>
 Please note: any valid EXIF image is a valid JPEG as well. ]]></DES>
</FUNC>

<FUNC caption="IsExifGpsBlob" code="IsExifGpsBlob()">
 <DES><![CDATA[<h4>IsExifGpsBlob( image <i>BLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL or not-BLOB argument.   <br>
 TRUE if this BLOB object corresponds to a valid EXIF-GPS image. <br>
 Please note: any valid EXIF-GPS image is a valid EXIF and JPEG as well. ]]></DES>
</FUNC>

<FUNC caption="IsWebpBlob" code="IsWebpBlob()">
 <DES><![CDATA[<h4>IsWebpBlob( image <i>BLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL or not-BLOB argument.   <br>
 TRUE if this BLOB object corresponds to a valid WebP image. ]]></DES>
</FUNC>

<FUNC caption="GetMimeType" code="GetMimeType()">
 <DES><![CDATA[<h4>GetMimeType( payload <i>BLOB</i> ) : <i>String</i></h4><br>
The return type is Text, and could be one of: <br>
 image/gif, image/png, image/jpeg, image/tiff, image/svg+xml, <br>
 application/xml, application/zip, application/pdf. <br>
 NULL could be returned for an invalid argument or if no valid mime-type is detected. ]]></DES>
</FUNC>

<FUNC caption="BlobFromFile" code="BlobFromFile()">
 <DES><![CDATA[<h4>BlobFromFile( filepath <i>String</i> ) : <i>BLOB</i></h4><br>
If filepath corresponds to some valid pathname, and the corresponding <br>
 file can be actually accessed in read mode, then the whole file content <br>
 will be returned as a BLOB value. Otherwise NULL will be returned. ]]></DES>
</FUNC>

<FUNC caption="BlobToFile" code="BlobToFile()">
 <DES><![CDATA[<h4>BlobToFile( payload <i>BLOB</i> , filepath <i>String</i> ) : <i>Integer</i></h4><br>
If payload is of the BLOB-type, and if filepath <br>
 corresponds to some valid pathname (accessible in write/create mode), <br>
 then the corresponding file will be created/overwritten so to contain the payload. <br>
 The return type is Integer, with a return value of 1 for success, 0 for failure. ]]></DES>
</FUNC>

<FUNC caption="CountUnsafeTriggers" code="CountUnsafeTriggers()">
 <DES><![CDATA[<h4>CountUnsafeTriggers( ) : <i>Integer</i></h4><br>
This SQL function checks if the currently connected DB does contain <br>
 any potentially malicious Trigger.The return type is Integer (total count of suspected Triggers); <br>
 0 means that the currently connected DB should be considered absolutely safe. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="8- Non-standard SQL for Geom" code="">
<DES>SQL  [non-standard] for geometric objects</DES>
<FUNC caption="GeomFromExifGpsBlob" code="GeomFromExifGpsBlob()">
 <DES><![CDATA[<h4>GeomFromExifGpsBlob( image <i>BLOB</i> ) : <i>Geometry</i></h4><br>
a POINT Geometry will be returned representing the GPS long/lat <br>
 contained within EXIF-GPS metadata for the BLOB image.   <br>
 NULL will be returned if it's not possible to build such a POINT ]]></DES>
</FUNC>

<FUNC caption="ST_Point" code="ST_Point()">
 <DES><![CDATA[<h4>ST_Point( x <i>Double precision</i> , y <i>Double precision</i> ) : <i>Geometry</i></h4><br>
An alias-name for MakePoint(). <br>
 Please note: the SRID argument is never supported by ST_Point(). ]]></DES>
</FUNC>

<FUNC caption="MakePoint" code="MakePoint()">
 <DES><![CDATA[<h4>MakePoint( x <i>Double precision</i> , y <i>Double precision</i> , [ , SRID <i>Integer</i>] ) : <i>Geometry</i></h4><br>
A Geometry will be returned representing the POINT defined by [x y] coordinates. ]]></DES>
</FUNC>

<FUNC caption="MakePointZ" code="MakePointZ()">
 <DES><![CDATA[<h4>MakePointZ( x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , [ , SRID <i>Integer</i>] ) : <i>Geometry</i></h4><br>
A Geometry will be returned representing the POINT Z defined by [x y z] coordinates. ]]></DES>
</FUNC>

<FUNC caption="MakePointM" code="MakePointM()">
 <DES><![CDATA[<h4>MakePointM( x <i>Double precision</i> , y <i>Double precision</i> , m <i>Double precision</i> , [ , SRID <i>Integer</i>] ) : <i>Geometry</i></h4><br>
A Geometry will be returned representing the POINT M defined by [x y m] coordinates. ]]></DES>
</FUNC>

<FUNC caption="MakePointZM" code="MakePointZM()">
 <DES><![CDATA[<h4>MakePointZM( x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , m <i>Double precision</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></h4><br>
A Geometry will be returned representing the POINT ZM defined by [x y z m] coordinates. ]]></DES>
</FUNC>

<FUNC caption="MakeLine (segment)" code="MakeLine()">
 <DES><![CDATA[<h4>MakeLine( pt1 <i>PointGeometry</i> , pt2 <i>PointGeometry</i> ) : <i>LineString</i></h4><br>
A LineString Geometry will be returned representing the segment connecting pt1 to pt2.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="MakeLine (from MultiPoint)" code="MakeLine()">
 <DES><![CDATA[<h4>MakeLine( geom <i>MultiPoint</i> , direction <i>Boolean</i> ) : <i>LineString</i></h4><br>
A LineString Geometry will be returned connecting all the input Points (accordingly to input sequence). <br>
 Direction=FALSE implies reverse order. NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="MakeCircle" code="MakeCircle()">
 <DES><![CDATA[<h4>MakeCircle( cx <i>Double precision</i> , cy <i>Double precision</i> , radius <i>Double precision</i> [ , SRID <i>Integer</i> [ , step <i>Double precision</i> ] ] ) : <i>Geometry</i></h4><br>
Returns a closed LineString approximating the Circle defined by cx, cy and radius. The optional <br>
 argument "step" defines how many points will be interpolated on the circumference; <br>
 a point will be set every step degrees. The implicit default setting corresponds to a <br>
 point every 10 degrees. ]]></DES>
</FUNC>

<FUNC caption="MakeEllipse" code="MakeEllipse()">
 <DES><![CDATA[<h4>MakeEllipse( cx <i>Double precision</i> , cy <i>Double precision</i> , x_axis <i>Double precision</i> , y_axis <i>Double precision</i> [ , SRID <i>Integer</i> [ , step <i>Double precision</i> ] ] ) : <i>Geometry</i></h4><br>
Returns a closed LineString approximating the Ellipse defined by cx, cy and x_axis, y_axis. <br>
 The optional argument "step" defines how many points will be interpolated on the ellipse; <br>
 a point will be set every step degrees. The implicit default setting corresponds to a <br>
 point every 10 degrees. ]]></DES>
</FUNC>

<FUNC caption="MakeArc" code="MakeArc()">
 <DES><![CDATA[<h4>MakeArc( cx <i>Double precision</i> , cy <i>Double precision</i> , radius <i>Double precision</i> , start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , step <i>Double precision</i> ] ] ) : <i>Geometry</i></h4><br>
Returns a LineString approximating the Circular Arc defined by cx, cy and radius. <br>
 The arc's extremities will be defined by start, stop angles expressed in degrees. <br>
 The optional argument "step" defines how many points will be interpolated on the circumference; <br>
 a point will be set every step degrees. The implicit default setting corresponds to a <br>
 point every 10 degrees. ]]></DES>
</FUNC>

<FUNC caption="MakeEllipticArc" code="MakeEllipticArc()">
 <DES><![CDATA[<h4>MakeEllipticArc( cx <i>Double precision</i> , cy <i>Double precision</i> , x_axis <i>Double precision</i> , y_axis <i>Double precision</i> , start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , step <i>Double precision</i> ] ] ) : <i>Geometry</i></h4><br>
Returns a LineString approximating the Elliptic Arc defined by cx, cy and x_axis, y_axis. <br>
 The arc's extremities will be defined by start and stop angles expressed in degrees. <br>
 The optional argument "step" defines how many points will be interpolated on the ellipse; <br>
 a point will be set every step degrees. The implicit default setting corresponds to a <br>
 point every 10 degrees. ]]></DES>
</FUNC>

<FUNC caption="MakeCircularSector" code="MakeCircularSector()">
 <DES><![CDATA[<h4>MakeCircularSector( cx <i>Double precision</i> , cy <i>Double precision</i> , radius <i>Double precision</i> , start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , step <i>Double precision</i> ] ] ) : <i>Geometry</i></h4><br>
Return a Polygon approximating the Circular Sector defined by cx, cy and radius. <br>
 The arc's extremities will be defined by start and stop angles expressed in degrees. <br>
 The optional argument "step" defines how many points will be interpolated on the circumference; <br>
 a point will be set every step degrees. The implicit default setting corresponds to a <br>
 point every 10 degrees. ]]></DES>
</FUNC>

<FUNC caption="MakeEllipticSector" code="MakeEllipticSector()">
 <DES><![CDATA[<h4>MakeEllipticSector( cx <i>Double precision</i> , cy <i>Double precision</i> , x_axis <i>Double precision</i> , y_axis <i>Double precision</i> , start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , step <i>Double precision</i> ] ] ) : <i>Geometry</i></h4><br>
Returns a Polygon approximating the Elliptic Sector defined by cx, cy and x_axis, y_axis. <br>
 The arc's extremities will be defined by start and stop angles expressed in degrees. <br>
 The optional argument "step" defines how many points will be interpolated on the ellipse; <br>
 a point will be set every step degrees. The implicit default setting corresponds to a <br>
 point every 10 degrees. ]]></DES>
</FUNC>

<FUNC caption="MakeCircularStripe" code="MakeCircularStripe()">
 <DES><![CDATA[<h4>MakeCircularStripe( cx <i>Double precision</i> , cy <i>Double precision</i> , radius_1 <i>Double precision</i> , radius_2 <i>Double precision</i> , start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , step <i>Double precision</i> ] ] ) : <i>Geometry</i></h4><br>
Returns a Polygon approximating the Circular Stripe delimited by two arcs sharing the same <br>
Centre [cx, cy] but having different radii [radius_1, radius_2]. <br>
 The arc's extremities will be defined by start and stop angles expressed in degrees. <br>
 The optional argument "step" defines how many points will be interpolated on the circumference; <br>
 a point will be set every step degrees. The implicit default setting corresponds to a <br>
 point every 10 degrees. ]]></DES>
</FUNC>

<FUNC caption="ST_SquareGrid" code="ST_SquareGrid()">
 <DES><![CDATA[<h4>ST_SquareGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , edges_only <i>Boolean</i> , [ origin <i>PointGeometry</i> ] ] ) : <i>Geometry</i></h4><br>
Returns a grid of square cells (having the edge length of size) precisely covering the input Geometry. <br>
 The returned Geometry will usually be of the MultiPolygon type (a collection of Squares) <br>
 but will be a MultiLinestring if the optional edges_only argument is set to TRUE. <br>
 If the optional origin argument (expected to be a Point) is not specified then the <br>
 (0,0) grid origin will be assumed by default.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_TriangularGrid" code="ST_TriangularGrid()">
 <DES><![CDATA[<h4>ST_TriangularGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , edges_only <i>Boolean</i> , [ origin <i>PointGeometry</i> ] ] ) : <i>Geometry</i></h4><br>
return a grid of triangular cells (having the edge length of size) precisely covering the input Geometry. <br>
 The returned Geometry will usually be of the MultiPolygon type (a collection of Squares) <br>
 but will be a MultiLinestring if the optional edges_only argument is set to TRUE. <br>
 If the optional origin argument (expected to be a Point) is not specified then the <br>
 (0,0) grid origin will be assumed by default.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_HexagonalGrid" code="ST_HexagonalGrid()">
 <DES><![CDATA[<h4>ST_HexagonalGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , edges_only <i>Boolean</i> , [ origin <i>PointGeometry</i> ] ] ) : <i>Geometry</i></h4><br>
return a grid of hexagonal cells (having the edge length of size) precisely covering the input Geometry. <br>
 The returned Geometry will usually be of the MultiPolygon type (a collection of Squares) <br>
 but will be a MultiLinestring if the optional edges_only argument is set to TRUE. <br>
 If the optional origin argument (expected to be a Point) is not specified then the <br>
 (0,0) grid origin will be assumed by default.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="BuildMbr" code="BuildMbr()">
 <DES><![CDATA[<h4>BuildMbr( x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></h4><br>
[x1 y1] and [x2 y2] are assumed to be Points identifying a line segment. <br>
 Returns a Geometry that represents the MBR for this line segment. ]]></DES>
</FUNC>

<FUNC caption="BuildCircleMbr" code="BuildCircleMbr()">
 <DES><![CDATA[<h4>BuildCircleMbr( x <i>Double precision</i> , y <i>Double precision</i> , radius <i>Double precision</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></h4><br>
[x y] is assumed to be the center of a circle of given radius. <br>
 Returns a Geometry that represents the MBR for this circle. ]]></DES>
</FUNC>

<FUNC caption="Extent" code="Extent()">
 <DES><![CDATA[<h4>Extent( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a Polygon that represents the bounding box that encloses a set of input values. <br>
Aggregate function. ]]></DES>
</FUNC>

<FUNC caption="ToGARS" code="ToGARS()">
 <DES><![CDATA[<h4>ToGARS( geom <i>Geometry</i> ) : <i>String</i></h4><br>
Geom is expected to represent a POINT (longitude and latitude coordinates). <br>
 Returns the corresponding GARS area designation code. <br> 
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="GARSMbr" code="GARSMbr()">
 <DES><![CDATA[<h4>GARSMbr( code <i>String</i> ) : <i>Geometry</i></h4><br>
Code is assumed to represent a valid GARS area designation code. <br>
 Returns a Geometry that represents the MBR for the corresponding GARS area.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_MinX" code="ST_MinX()">
 <DES><![CDATA[<h4>ST_MinX( geom <i>Geometry</i>) : <i>Double precision</i></h4><br>
Returns the x-coordinate for geom MBR's leftmost side as a double precision number.   <br>
 NULL will be returned if geom isn't a valid Geometry. ]]></DES>
</FUNC>

<FUNC caption="ST_MinY" code="ST_MinY()">
 <DES><![CDATA[<h4>ST_MinY( geom <i>Geometry</i>) : <i>Double precision</i></h4><br>
Returns the y-coordinate for geom MBR's lowermost side as a double precision number.   <br>
 NULL will be returned if geom isn't a valid Geometry. ]]></DES>
</FUNC>

<FUNC caption="ST_MaxX" code="ST_MaxX()">
 <DES><![CDATA[<h4>ST_MaxX( geom <i>Geometry</i>) : <i>Double precision</i></h4><br>
Returns the x-coordinate for geom MBR's rightmost side as a double precision number.   <br>
 NULL will be returned if geom isn't a valid Geometry. ]]></DES>
</FUNC>

<FUNC caption="ST_MaxY" code="ST_MaxY()">
 <DES><![CDATA[<h4>ST_MaxY( geom <i>Geometry</i>) : <i>Double precision</i></h4><br>
Returns the y-coordinate for geom MBR's uppermost side as a double precision number.   <br>
 NULL will be returned if geom isn't a valid Geometry. ]]></DES>
</FUNC>

<FUNC caption="ST_MinZ" code="ST_MinZ()">
 <DES><![CDATA[<h4>ST_MinZ( geom <i>Geometry</i>) : <i>Double precision</i></h4><br>
Returns the minimum Z-coordinate value for geom as a double precision number.   <br>
 NULL will be returned if geom isn't a valid Geometry or if geom has no Z dimension. ]]></DES>
</FUNC>

<FUNC caption="ST_MaxZ" code="ST_MaxZ()">
 <DES><![CDATA[<h4>ST_MaxZ( geom <i>Geometry</i>) : <i>Double precision</i></h4><br>
Returns the maximum Z-coordinate value for geom as a double precision number.   <br>
 NULL will be returned if geom isn't a valid Geometry or if geom has no Z dimension. ]]></DES>
</FUNC>

<FUNC caption="ST_MinM" code="ST_MinM()">
 <DES><![CDATA[<h4>ST_MinM( geom <i>Geometry</i>) : <i>Double precision</i></h4><br>
Returns the minimum M-coordinate value for geom as a double precision number.   <br>
 NULL will be returned if geom isn't a valid Geometry or if geom has no M dimension. ]]></DES>
</FUNC>

<FUNC caption="ST_MaxM" code="ST_MaxM()">
 <DES><![CDATA[<h4>ST_MaxM( geom <i>Geometry</i>) : <i>Double precision</i></h4><br>
Returns the maximum M-coordinate value for geom as a double precision number.   <br>
 NULL will be returned if geom isn't a valid Geometry or if geom has no M dimension. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="9- Geometry from WKT" code="">
<DES>SQL functions for constructing a geometric object given its Well-known Text Representation</DES>
<FUNC caption="ST_GeomFromText" code="ST_GeomFromText()">
 <DES><![CDATA[<h4>ST_GeomFromText( wkt <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></h4><br>
Constructs a geometric object from its Well-known text Representation. ]]></DES>
</FUNC>

<FUNC caption="ST_WKTToSQL" code="ST_WKTToSQL()">
 <DES><![CDATA[<h4>ST_WKTToSQL( wkt <i>String</i> ) : <i>Geometry</i></h4><br>
SQL/MM compliant: simply an alias name for ST_GeomFromText.   <br>
 Please note: SRID=0 is always assumed. ]]></DES>
</FUNC>

<FUNC caption="ST_PointFromText" code="ST_PointFromText()">
 <DES><![CDATA[<h4>ST_PointFromText( wktPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Point</i></h4><br>
Constructs a Point. ]]></DES>
</FUNC>

<FUNC caption="ST_LineStringFromText" code="ST_LineStringFromText()">
 <DES><![CDATA[<h4>ST_LineStringFromText( wktLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>LineString</i></h4><br>
Constructs a LineString. ]]></DES>
</FUNC>

<FUNC caption="ST_PolygonFromText" code="ST_PolygonFromText()">
 <DES><![CDATA[<h4>ST_PolygonFromText( wktPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></h4><br>
Constructs a Polygon. ]]></DES>
</FUNC>

<FUNC caption="ST_MultiPointFromText" code="ST_MultiPointFromText()">
 <DES><![CDATA[<h4>ST_MultiPointFromText( wktMultiPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i></h4><br>
Constructs a MultiPoint. ]]></DES>
</FUNC>

<FUNC caption="ST_MultiLineStringFromText" code="ST_MultiLineStringFromText()">
 <DES><![CDATA[<h4>ST_MultiLineStringFromText( wktMultiLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiLineString</i>   </h4><br>
Constructs a MultiLineString. ]]></DES>
</FUNC>

<FUNC caption="ST_MultiPolygonFromText" code="ST_MultiPolygonFromText()">
 <DES><![CDATA[<h4>ST_MultiPolygonFromText( wktMultiPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></h4><br>
Constructs a MultiPolygon. ]]></DES>
</FUNC>

<FUNC caption="ST_GeometryCollectionFromText" code="ST_GeometryCollectionFromText()">
 <DES><![CDATA[<h4>ST_GeometryCollectionFromText<( wktGeometryCollection <i>String</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i>   </h4><br>
Constructs a GeometryCollection. ]]></DES>
</FUNC>

<FUNC caption="ST_BdPolyFromText" code="ST_BdPolyFromText()">
 <DES><![CDATA[<h4>ST_BdPolyFromText( wktMultilinestring <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></h4><br>
Constructs a Polygon given an arbitrary collection of closed linestrings as a <br>
 MultiLineString text representation.    See also: BuildArea(), Polygonize(). ]]></DES>
</FUNC>

<FUNC caption="ST_BdMPolyFromText" code="ST_BdMPolyFromText()">
 <DES><![CDATA[<h4>ST_BdMPolyFromText( wktMultilinestring <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></h4><br>
Constructs a MultiPolygon given an arbitrary collection of closed linestrings as a <br>
 MultiLineString text representation.    See also: BuildArea(), Polygonize(). ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="10- Geometry from WKB" code="">
<DES>SQL functions for constructing a geometric object given its Well-known Binary Representation</DES>
<FUNC caption="ST_GeomFromWKB" code="ST_GeomFromWKB()">
 <DES><![CDATA[<h4>ST_GeomFromWKB( wkbGeometry <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></h4><br>
Constructs a geometric object given its Well-known binary Representation. ]]></DES>
</FUNC>

<FUNC caption="ST_WKBToSQL" code="ST_WKBToSQL()">
 <DES><![CDATA[<h4>ST_WKBToSQL( wkbGeometry <i>Binary</i> ) : <i>Geometry</i></h4><br>
SQL/MM compliant: simply an alias name for ST_GeomFromWKB.   <br>
 Please note: SRID=0 is always assumed. ]]></DES>
</FUNC>

<FUNC caption="ST_PointFromWKB" code="ST_PointFromWKB()">
 <DES><![CDATA[<h4><i>ST_PointFromWKB( wkbPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Point</i></h4><br>
Constructs a Point. ]]></DES>
</FUNC>

<FUNC caption="ST_LineStringFromWKB" code="ST_LineStringFromWKB()">
 <DES><![CDATA[<h4>ST_LineStringFromWKB( wkbLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>LineString</i></h4><br>
Constructs a LineString. ]]></DES>
</FUNC>

<FUNC caption="ST_PolygonFromWKB" code="ST_PolygonFromWKB()">
 <DES><![CDATA[<h4>ST_PolygonFromWKB( wkbPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></h4><br>
Constructs a Polygon. ]]></DES>
</FUNC>

<FUNC caption="ST_MultiPointFromWKB" code="ST_MultiPointFromWKB()">
 <DES><![CDATA[<h4>ST_MultiPointFromWKB( wkbMultiPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i></h4><br>
Constructs a MultiPoint. ]]></DES>
</FUNC>

<FUNC caption="ST_MultiLineStringFromWKB" code="ST_MultiLineStringFromWKB()">
 <DES><![CDATA[<h4>ST_MultiLineStringFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiLineString</i></h4><br>
Constructs a MultiLineString. ]]></DES>
</FUNC>

<FUNC caption="ST_MultiPolygonFromWKB" code="ST_MultiPolygonFromWKB()">
 <DES><![CDATA[<h4>ST_MultiPolygonFromWKB( wkbMultiPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></h4><br>
Constructs a MultiPolygon. ]]></DES>
</FUNC>

<FUNC caption="ST_GeometryCollectionFromWKB" code="ST_GeometryCollectionFromWKB()">
 <DES><![CDATA[<h4>ST_GeometryCollectionFromWKB( wkbGeometryCollection <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i></h4><br>
Constructs a GeometryCollection. ]]></DES>
</FUNC>

<FUNC caption="ST_BdPolyFromWKB" code="ST_BdPolyFromWKB()">
 <DES><![CDATA[<h4>ST_BdPolyFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></h4><br>
Constructs a Polygon given an arbitrary collection of closed linestrings as a <br>
 MultiLineString binary representation.    See also: BuildArea(), Polygonize(). ]]></DES>
</FUNC>

<FUNC caption="ST_BdMPolyFromWKB" code="ST_BdMPolyFromWKB()">
 <DES><![CDATA[<h4>ST_BdMPolyFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></h4><br>
Constructs a MultiPolygon given an arbitrary collection of closed linestrings as a <br>
 MultiLineString binary representation.    See also: BuildArea(), Polygonize(). ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="11- WKT/WKB from geometry" code="">
<DES>SQL functions for obtaining the Well-known Text / Well-known Binary Representation of a geometric object</DES>

<FUNC caption="ST_AsText" code="ST_AsText()">
 <DES><![CDATA[<h4>ST_AsText( geom <i>Geometry</i> ) : <i>String</i></h4><br>
Returns the Well-known Text representation of geom. ]]></DES>
</FUNC>

<FUNC caption="AsWKT" code="AsWKT()">
 <DES><![CDATA[<h4>AsWKT( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i></h4><br>
Returns the Well-known Text representation of geom. <br>
Always return strictly conformant 2D WKT. ]]></DES>
</FUNC>

<FUNC caption="ST_AsBinary" code="ST_AsBinary()">
 <DES><![CDATA[<h4>ST_AsBinary( geom <i>Geometry</i> ) : <i>Binary</i></h4><br>
Returns the Well-known Binary representation of geom.]]></DES>
</FUNC>
</GROUP>
<GROUP caption="12- Exotic formats" code="">
<DES>SQL functions supporting exotic geometric formats</DES>

<FUNC caption="AsSVG" code="AsSVG()">
 <DES><![CDATA[<h4>AsSVG( geom <i>Geometry</i> [ , relative <i>Integer</i> [ , precision <i>Integer</i> ] ] ) : <i>String</i></h4><br>
Returns the SVG [Scalable Vector Graphics] representation. ]]></DES>
</FUNC>

<FUNC caption="AsKml" code="AsKml()">
 <DES><![CDATA[<h4>AsKml( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i> <br>
 AsKml( name <i>String</i>, description <i>String</i>, geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i></h4><br>
Returns the KML [Keyhole Markup Language] representation. <br>
 The first form will simply generate the geometry element. <br>
 The second form will generate a complete KML entity. ]]></DES>
</FUNC>

<FUNC caption="GeomFromKml" code="GeomFromKml()">
 <DES><![CDATA[<h4>GeomFromKml( KmlGeometry <i>String</i> ) : <i>Geometry</i></h4><br>
Constructs a geometric object given its KML Representation. ]]></DES>
</FUNC>

<FUNC caption="AsGml" code="AsGml()">
 <DES><![CDATA[<h4>AsGml( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i> <br>
 AsGml( version <i>Integer</i>, geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i></h4><br>
Returns the GML [Geography Markup Language] representation. <br>
 If version = 3 than GML 3.x is generated, otherwise the output format will be GML 2.x. ]]></DES>
</FUNC>

<FUNC caption="GeomFromGML" code="GeomFromGML()">
 <DES><![CDATA[<h4>GeomFromGML( gmlGeometry <i>String</i> ) : <i>Geometry</i></h4><br>
Constructs a geometric object given its GML Representation. ]]></DES>
</FUNC>

<FUNC caption="AsGeoJSON" code="AsGeoJSON()">
 <DES><![CDATA[<h4>AsGeoJSON( geom <i>Geometry</i> [ , precision <i>Integer</i> [ , options <i>Integer</i> ] ] ) : <i>String</i></h4><br>
Returns the GeoJSON [Geographic JavaScript Object Notation] representation. <br>
Options can assume the following values:  <br>
0 no options [default] <br>
1 GeoJSON BoundingBox <br>
2 GeoJSON CRS [short version] <br>
3 BoundingBox + short CRS <br>
4 GeoJSON CRS [long version] <br>
5 BoundingBox + long CRS. ]]></DES>
</FUNC>

<FUNC caption="GeomFromGeoJSON" code="GeomFromGeoJSON()">
 <DES><![CDATA[<h4>GeomFromGeoJSON( geoJSONGeometry <i>String</i> ) : <i>Geometry</i></h4><br>
Constructs a geometric object given its GeoJSON Representation. ]]></DES>
</FUNC>

<FUNC caption="AsEWKB" code="AsEWKB()">
 <DES><![CDATA[<h4>AsEWKB( geom <i>Geometry</i> ) : <i>Binary</i></h4><br>
Returns the EWKB [Extended Well Known Binary] representation (PostGIS compatibility). ]]></DES>
</FUNC>

<FUNC caption="GeomFromEWKB" code="GeomFromEWKB()">
 <DES><![CDATA[<h4>GeomFromEWKB( ewkbGeometry <i>Binary</i> ) : <i>Geometry</i></h4><br>
Constructs a geometric object given its EWKB Representation. ]]></DES>
</FUNC>

<FUNC caption="AsEWKT" code="AsEWKT()">
 <DES><![CDATA[<h4>AsEWKT( geom <i>Geometry</i> ) : <i>String</i></h4><br>
Returns the EWKT [Extended Well Known Text] representation (PostGIS compatibility). ]]></DES>
</FUNC>

<FUNC caption="GeomFromEWKT" code="GeomFromEWKT()">
 <DES><![CDATA[<h4>GeomFromEWKT( ewktGeometry <i>String</i> ) : <i>Geometry</i></h4><br>
Constructs a geometric object given its EWKT Representation. ]]></DES>
</FUNC>

<FUNC caption="AsFGF" code="AsFGF()">
 <DES><![CDATA[<h4>AsFGF( geom <i>Geometry</i> ) : <i>Binary</i></h4><br>
Returns the FGF [FDO Geometry Binary Format] representation. ]]></DES>
</FUNC>

<FUNC caption="GeomFromFGF" code="GeomFromFGF()">
 <DES><![CDATA[<h4>GeomFromFGF( fgfGeometry <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></h4><br>
Constructs a geometric object given its FGF binary Representation. ]]></DES>
</FUNC>

<FUNC caption="ExportDXF" code="ExportDXF()">
 <DES><![CDATA[<h4>ExportDXF( out_dir <i>String</i> , filename <i>String</i> , sql_query <i>String</i> , layer_col_name <i>String</i> , geom_col_name <i>String</i> , label_col_name <i>String</i> , text_height_col_name <i>String</i> , text_rotation_col_name <i>String</i> , geom_filter <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>Integer</i></h4><br>
Will export a whole DXF file. The output file path is controlled by out_dir and filename. <br>
 sql_query is a complete SQL Statement returning the dataset to be exported. <br>
 layer_col_name, geom_col_name, label_col_name, text_height_col_name and text_rotation_col_name <br>
 must specify the corresponding column names within the resultset returned by sql_query <br>
 (label_col_name, text_height_col_name and text_rotation_col_name could be eventually NULL). <br>
 geom_filter acts as a spatial filter selecting which entities have to be exported (could be NULL). <br>
 The optional argument precision specificies how many decimal digits are required for coordinate values: <br>
 if not specified the default is 3. Will return 0 (i.e. FALSE) on failure, any other value (i.e. TRUE) on success. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="13- SQL for Geometries" code="">
<DES>SQL functions on type Geometry</DES>

<FUNC caption="ST_Dimension" code="ST_Dimension()">
 <DES><![CDATA[<h4>ST_Dimension( geom <i>Geometry</i> ) : <i>Integer</i></h4><br>
Returns the dimension of the geometric object, which is less than or equal to the dimension of the coordinate space. ]]></DES>
</FUNC>

<FUNC caption="CoordDimension" code="CoordDimension()">
 <DES><![CDATA[<h4>CoordDimension( geom <i>Geometry</i> ) : <i>String</i></h4><br>
Returns the dimension model used by the geometric object as: 'XY', 'XYZ', 'XYM' or 'XYZM'. ]]></DES>
</FUNC>

<FUNC caption="ST_NDims" code="ST_NDims()">
 <DES><![CDATA[<h4>ST_NDims( geom <i>Geometry</i> ) : <i>Integer</i></h4><br>
Returns the number of dimensions used by the geometric object as: 2, 3 or 4. ]]></DES>
</FUNC>

<FUNC caption="ST_Is3D" code="ST_Is3D()">
 <DES><![CDATA[<h4>ST_Is3D( geom <i>Geometry</i> ) : <i>Integer</i></h4><br>
Checks if geom has the Z dimension. The return type is Integer, with a return value of <br>
 1 for TRUE, 0 for FALSE, and -1 for UNKNOWN corresponding to a function invocation on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="ST_IsMeasured" code="ST_IsMeasured()">
 <DES><![CDATA[<h4>ST_IsMeasured( geom <i>Geometry</i> ) : <i>Integer</i></h4><br>
Check if geom has the M dimension. The return type is Integer, with a return value of <br>
 1 for TRUE, 0 for FALSE, and -1 for UNKNOWN corresponding to a function invocation on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="ST_GeometryType" code="ST_GeometryType()">
 <DES><![CDATA[<h4>ST_GeometryType( geom <i>Geometry</i> ) : <i>String</i></h4><br>
Returns the name of the instantiable subtype of Geometry <br>
 of which this geometric object is a member, as a string. ]]></DES>
</FUNC>

<FUNC caption="ST_SRID" code="ST_SRID()">
 <DES><![CDATA[<h4>ST_SRID( geom <i>Geometry</i> ) : <i>Integer</i></h4><br>
Returns the Spatial Reference System ID for this geometric object. ]]></DES>
</FUNC>

<FUNC caption="SetSRID" code="SetSRID()">
 <DES><![CDATA[<h4>SetSRID( geom <i>Geometry</i> , SRID <i>Integer</i> ) : <i>Integer</i></h4><br>
Directly sets the Spatial Reference System ID for this geometric object <br>
 [no reprojection is applied]   The return type is Integer, with a return value of <br>
 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN corresponding to a function invocation on NULL arguments. ]]></DES>
</FUNC>

<FUNC caption="ST_IsEmpty" code="ST_IsEmpty()">
 <DES><![CDATA[<h4>ST_IsEmpty( geom <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of <br>
 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN corresponding to a function invocation on NULL arguments.   <br>
 TRUE if this geometric object corresponds to the empty set. ]]></DES>
</FUNC>

<FUNC caption="ST_IsSimple" code="ST_IsSimple()">
 <DES><![CDATA[<h4>ST_IsSimple( geom <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of <br>
 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN corresponding to a function invocation on NULL arguments.   <br>
 TRUE if this geometric object is simple, as defined in the Geometry Model. ]]></DES>
</FUNC>

<FUNC caption="ST_IsValid" code="ST_IsValid()">
 <DES><![CDATA[<h4>ST_IsValid( geom <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of <br>
 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN corresponding to a function invocation on NULL arguments.   <br>
 TRUE if this geometric object does not contains any topological error. ]]></DES>
</FUNC>

<FUNC caption="ST_IsValidReason" code="ST_IsValidReason()">
 <DES><![CDATA[<h4>ST_IsValidReason( geom <i>Geometry</i> ) : <i>String</i></h4><br>
Will return a TEXT string stating if a Geometry is valid and if not valid, a reason why.   <br>
 NULL will be returned on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="ST_IsValidDetail" code="ST_IsValidDetail()">
 <DES><![CDATA[<h4>ST_IsValidDetail( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Will return a Geometry detail (usually a POINT) causing invalidity.   <br>
 NULL will be returned on invalid arguments, or in the case of a valid Geometry. ]]></DES>
</FUNC>

<FUNC caption="ST_Boundary" code="ST_Boundary()">
 <DES><![CDATA[<h4>ST_Boundary( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object that is the combinatorial boundary of g as defined in the Geometry Model. ]]></DES>
</FUNC>

<FUNC caption="ST_Envelope" code="ST_Envelope()">
 <DES><![CDATA[<h4>ST_Envelope( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns the rectangle bounding g as a Polygon. The Polygon is defined by the corner points of the <br>
 bounding box [(MINX, MINY),(MAXX, MINY), (MAXX, MAXY), (MINX, MAXY), (MINX, MINY)]. ]]></DES>
</FUNC>

<FUNC caption="ST_Expand" code="ST_Expand()">
 <DES><![CDATA[<h4>ST_Expand( geom <i>Geometry</i> , amount <i>Double precision</i> ) : <i>Geometry</i></h4><br>
Returns the rectangle bounding g as a Polygon. The bounding rectangle <br>
 is expanded in all directions by an amount specified by the second argument. ]]></DES>
</FUNC>

<FUNC caption="ST_NPoints" code="ST_NPoints()">
 <DES><![CDATA[<h4>ST_NPoints( geom <i>Geometry</i> ) : <i>Integer</i></h4><br>
Returns the total number of Points (this including any Linestring/Polygon vertex). ]]></DES>
</FUNC>

<FUNC caption="ST_NRings" code="ST_NRings()">
 <DES><![CDATA[<h4>ST_NRings( geom <i>Geometry</i> ) : <i>Integer</i></h4><br>
Returns the total number of Rings (this including both Exterior and Interior Rings). ]]></DES>
</FUNC>

<FUNC caption="ST_Reverse" code="ST_Reverse()">
 <DES><![CDATA[<h4>ST_Reverse( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a new Geometry [if a valid Geometry was supplied], or NULL in any other case.   <br>
 Any Linestring or Ring will be in reverse order (first vertex will be the last one, and last vertex will be the first one). ]]></DES>
</FUNC>

<FUNC caption="ST_ForceLHR" code="ST_ForceLHR()">
 <DES><![CDATA[<h4>ST_ForceLHR( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a new Geometry [if a valid Geometry was supplied], or NULL in any other case.   <br>
 Any Polygon Ring will be oriented accordingly to Left Hand Rule <br>
 (Exterior Ring will be clockwise oriented, and Interior Rings will be <br>
 counter-clockwise oriented). ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="14- Repair Geometries" code="">
<DES>SQL functions attempting to repair malformed Geometries</DES>
<FUNC caption="SanitizeGeometry" code="SanitizeGeometry()">
 <DES><![CDATA[<h4>SanitizeGeometry( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a (possibly) sanitized Geometry [if a valid Geometry was supplied], or NULL in any other case. <br>
Please note: current implementations only affects: repeated vertices suppression Ring's closure enforcement. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="15- Compress Geometries" code="">
<DES>SQL Geometry-compression functions</DES>
<FUNC caption="CompressGeometry" code="CompressGeometry()">
 <DES><![CDATA[<h4>CompressGeometry( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a compressed Geometry [if a valid Geometry was supplied], or NULL in any other case. <br>
Please note: geometry compression only affects LINESTRINGs and POLYGONs, not POINTs. ]]></DES>
</FUNC>

<FUNC caption="UncompressGeometry" code="UncompressGeometry()">
 <DES><![CDATA[<h4>UncompressGeometry( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns an uncompressed Geometry [if a valid Geometry was supplied], or NULL in any other case. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="16- Cast Geometries" code="">
<DES>SQL Geometry-type casting functions</DES>
<FUNC caption="CastToPoint" code="CastToPoint()">
 <DES><![CDATA[<h4>CastToPoint( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a POINT-type Geometry [if type-conversion is possible], or NULL in any other case.   <br>
 Can be applied to any Geometry containing only a single POINT and no other elementary sub-geometry. ]]></DES>
</FUNC>

<FUNC caption="CastToLinestring" code="CastToLinestring()">
 <DES><![CDATA[<h4>CastToLineString( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a LINESTRING-type Geometry [if type-conversion is possible], or NULL in any other case.   <br>
 Can be applied to any Geometry containing only a single LINESTRING and no other elementary sub-geometry. ]]></DES>
</FUNC>

<FUNC caption="CastToPolygon" code="CastToPolygon()">
 <DES><![CDATA[<h4>CastToPolygon( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a POLYGON-type Geometry [if type-conversion is possible], or NULL in any other case.   <br>
 Can be applied to any Geometry containing only a single POLYGON and no other elementary sub-geometry. ]]></DES>
</FUNC>

<FUNC caption="CastToMultiPoint" code="CastToMultiPoint()">
 <DES><![CDATA[<h4>CastToMultiPoint( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a MULTIPOINT-type Geometry [if type-conversion is possible], or NULL in any other case.   <br>
 Can be applied to any Geometry containing one or more POINT(s) and no other elementary sub-geometry. ]]></DES>
</FUNC>

<FUNC caption="CastToMultiLinestring" code="CastToMultiLinestring()">
 <DES><![CDATA[<h4>CastToMultiLineString( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a MULTILINESTRING-type Geometry [if type-conversion is possible], or NULL in any other case.   <br>
 Can be applied to any Geometry containing one or more LINESTRING(s) and no other elementary sub-geometry. ]]></DES>
</FUNC>

<FUNC caption="CastToMultiPolygon" code="CastToMultiPolygon()">
 <DES><![CDATA[<h4>CastToMultiPolygon( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a MULTIPOLYGON-type Geometry [if type-conversion is possible], or NULL in any other case.   <br>
 Can be applied to any Geometry containing one or more POLYGON(s) and no other elementary sub-geometry. ]]></DES>
</FUNC>

<FUNC caption="CastToGeometryCollection" code="CastToGeometryCollection()">
 <DES><![CDATA[<h4>CastToGeometryCollection( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a GEOMETRYCOLLECTION-type Geometry [if type-conversion is possible], or NULL in any other case.   <br>
 Can be applied to any valid Geometry. ]]></DES>
</FUNC>

<FUNC caption="CastToMulti" code="CastToMulti()">
 <DES><![CDATA[<h4>CastToMulti( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a MULTIPOINT-, MULTILINESTRING- or MULTIPOLYGON-type Geometry [if type-conversion is possible], or NULL in any other case.    <br>
 A MULTIPOINT will be returned for a Geometry containing one or more POINT(s) <br>
 and no other elementary sub-geometry a MULTILINESTRING will be returned for a <br>
 Geometry containing one or more LINESTRING(s) and no other elementary sub-geometry <br>
 a MULTIPOLYGON will be returned for a Geometry containing one or more POLYGON(s) and <br>
 no other elementary sub-geometry a GEOMETRYCOLLECTION will be returned for any other <br>
 valid Geometry. ]]></DES>
</FUNC>

<FUNC caption="CastToSingle" code="CastToSingle()">
 <DES><![CDATA[<h4>CastToSingle( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a POINT-, LINESTRING- or POLYGON-type Geometry [if type-conversion is possible], or NULL in any other case.   <br>
 A POINT will be returned for a Geometry containing only a single POINT and no other elementary <br>
 sub-geometry a LINESTRING will be returned for a Geometry containing only a single LINESTRING and <br>
 no other elementary sub-geometry a POLYGON will be returned for a Geometry containing only a single <br>
 POLYGON and no other elementary sub-geometry. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="17- Cast dimensions" code="">
<DES>SQL Space-dimensions casting functions</DES>
<FUNC caption="CastToXY" code="CastToXY()">
 <DES><![CDATA[<h4>CastToXY( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a Geometry using the [XY] space dimension. ]]></DES>
</FUNC>

<FUNC caption="CastToXYZ" code="CastToXYZ()">
 <DES><![CDATA[<h4>CastToXYZ( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a Geometry using the [XYZ] space dimension. ]]></DES>
</FUNC>

<FUNC caption="CastToXYM" code="CastToXYM()">
 <DES><![CDATA[<h4>CastToXYM( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a Geometry using the [XYZM] space dimension. ]]></DES>
</FUNC>

<FUNC caption="CastToXYZM" code="CastToXYZM()">
 <DES><![CDATA[<h4>CastToXYZM( geom <i>Geometry</i> ) : geom <i>Geometry</i></h4><br>
Returns a Geometry using the [XYZM] space dimension. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="18- SQL for Points" code="">
<DES>SQL functions on type Point</DES>
<FUNC caption="ST_X" code="ST_X()">
 <DES><![CDATA[<h4>ST_X( pt <i>Point</i> ) : <i>Double precision</i></h4><br>
Return the x-coordinate of Point pt as a double precision number. ]]></DES>
</FUNC>

<FUNC caption="ST_Y" code="ST_Y()">
 <DES><![CDATA[<h4>ST_Y( pt <i>Point</i> ) : <i>Double precision</i></h4><br>
Return the y-coordinate of Point pt as a double precision number. ]]></DES>
</FUNC>

<FUNC caption="ST_Z" code="ST_Z()">
 <DES><![CDATA[<h4>ST_Z( pt <i>Point</i> ) : <i>Double precision</i></h4><br>
Return the z-coordinate of Point pt as a double precision number or NULL if no z-coordinate is available. ]]></DES>
</FUNC>

<FUNC caption="ST_M" code="ST_M()">
 <DES><![CDATA[<h4>ST_M( pt <i>Point</i> ) : <i>Double precision</i></h4><br>
Return the m-coordinate of Point pt as a double precision number or NULL if no m-coordinate is available. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="19- SQL for Curves" code="">
<DES>SQL functions on type Curve [Linestring or Ring]</DES>
<FUNC caption="ST_StartPoint" code="ST_StartPoint()">
 <DES><![CDATA[<h4>ST_StartPoint( c <i>Curve</i> ) : <i>Point</i></h4><br>
return a Point containing the first Point of c. ]]></DES>
</FUNC>

<FUNC caption="ST_EndPoint" code="ST_EndPoint()">
 <DES><![CDATA[<h4>ST_EndPoint( c <i>Curve</i> ) : <i>Point</i></h4><br>
return a Point containing the last Point of c. ]]></DES>
</FUNC>

<FUNC caption="ST_Length" code="ST_Length()">
 <DES><![CDATA[<h4>ST_Length( c <i>Curve</i> ) : <i>Double precision</i> <br>
 ST_Length( c <i>Curve</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i></h4><br>
Return the length of c. <br>
 ]]></DES>
</FUNC>

<FUNC caption="ST_Perimeter" code="ST_Perimeter()">
 <DES><![CDATA[<h4>ST_Perimeter( s <i>Surface</i> ) : <i>Double precision</i></h4><br>
Return the perimeter of s.   Starting since v.4.0.0 this function will simply <br>
 consider Polygons and MultiPolygons, ignoring any LineString or MultiLineString. ]]></DES>
</FUNC>

<FUNC caption="GeodesicLength" code="GeodesicLength()">
 <DES><![CDATA[<h4>GeodesicLength( c <i>Curve</i> ) : <i>Double precision</i></h4><br>
If [and only if] the SRID associated with c is a geographic one [i.e. one using <br>
 longitude and latitude angles], then returns the length of c measured on the Ellipsoid <br>
 [such length is always expressed in meters] Otherwise NULL will be returned.   <br>
 Please note: measuring lengths on the Ellipsoid requires complex geodesic calculations, <br>
 and thus is an intrinsically slow and time consuming task. ]]></DES>
</FUNC>

<FUNC caption="GreatCircleLength" code="GreatCircleLength()">
 <DES><![CDATA[<h4>GreatCircleLength( c <i>Curve</i> ) : <i>Double precision</i></h4><br>
If [and only if] the SRID associated with c is a geographic one [i.e. one using <br>
 longitude and latitude angles], then returns the length of c measured on the Great Circle <br>
 [such length is always expressed in meters] Otherwise NULL will be returned.   <br>
 Please note: lengths measured on the Great Circle are less precise than lengths measured <br>
 on the Ellipsoid using complex geodesic calculations; but they are by far quickest to compute. ]]></DES>
</FUNC>

<FUNC caption="ST_IsClosed" code="ST_IsClosed()">
 <DES><![CDATA[<h4>ST_IsClosed( c <i>Curve</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments;   <br>
 return TRUE if c is closed, i.e., if StartPoint(c) = EndPoint(c). ]]></DES>
</FUNC>

<FUNC caption="ST_IsRing" code="ST_IsRing()">
 <DES><![CDATA[<h4>ST_IsRing( c <i>Curve</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 return TRUE if c is a ring, i.e., if c is closed and simple. <br>
 A simple Curve does not pass through the same Point more than once. ]]></DES>
</FUNC>

<FUNC caption="ST_PointOnSurface" code="ST_PointOnSurface()">
 <DES><![CDATA[<h4>ST_PointOnSurface( s <i>Surface/Curve</i> ) : <i>Point</i></h4><br>
Return a Point guaranteed to lie on the Surface (or Curve). ]]></DES>
</FUNC>

<FUNC caption="ST_Simplify" code="ST_Simplify()">
 <DES><![CDATA[<h4>ST_Simplify( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i></h4><br>
Return a geometric object representing a simplified version of c applying the <br>
 Douglas-Peukert algorithm with given tolerance. ]]></DES>
</FUNC>

<FUNC caption="ST_SimplifyPreserveTopology" code="ST_SimplifyPreserveTopology()">
 <DES><![CDATA[<h4>ST_SimplifyPreserveTopology( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i></h4><br>
return a geometric object representing a simplified version of c applying the <br>
 Douglas-Peukert algorithm with given tolerance and respecting topology. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="20- SQL for LineStrings" code="">
<DES>SQL functions on type LineString</DES>
<FUNC caption="ST_NumPoints" code="ST_NumPoints()">
 <DES><![CDATA[<h4>ST_NumPoints( line <i>LineString</i> ) : <i>Integer</i></h4><br>
return the number of Points in the LineString. ]]></DES>
</FUNC>

<FUNC caption="ST_PointN" code="ST_PointN()">
 <DES><![CDATA[<h4>ST_PointN( line <i>LineString</i> , n <i>Integer</i> ) : <i>Point</i></h4><br>
Returns a Point containing Point n of line. ]]></DES>
</FUNC>

<FUNC caption="ST_AddPoint" code="ST_AddPoint()">
 <DES><![CDATA[<h4>ST_AddPoint( line <i>LineString</i> , point <i>Point</i> [ , position <i>Integer</i> ] ) : <i>LineString</i></h4><br>
Returns a new LineString by adding a new Point into the input Linestring <br>
 immediately before position (zero-based index). A negative position (default) <br>
 means appending the new Point to the end of the input Linestring. <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_SetPoint" code="ST_SetPoint()">
 <DES><![CDATA[<h4>ST_SetPoint( line <i>LineString</i> , position <i>Integer</i> , point <i>Point</i> ) : <i>LineString</i></h4><br>
Returns a new LineString by replacing the Point at position (zero-based index). <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_RemovePoint" code="ST_RemovePoint()">
 <DES><![CDATA[<h4>ST_RemovePoint( line <i>LineString</i> , position <i>Integer</i> ) : <i>LineString</i></h4><br>
Returns a new Linestring by removing the Point at position (zero-based index). <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="21- SQL for Surfaces" code="">
<DES>SQL functions on type Surface [Polygon or Ring]</DES>
<FUNC caption="ST_Centroid" code="ST_Centroid()">
 <DES><![CDATA[<h4>ST_Centroid( s <i>Surface</i> ) : <i>Point</i></h4><br>
Returns the centroid of s, which may lie outside s. ]]></DES>
</FUNC>

<FUNC caption="ST_Area" code="ST_Area()">
 <DES><![CDATA[<h4>ST_Area( s <i>Surface</i> ) : <i>Double precision</i></h4><br>
Returns the area of s. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="22- SQL for Polygons" code="">
<DES>SQL functions on type Polygon</DES>
<FUNC caption="ST_ExteriorRing" code="ST_ExteriorRing()">
 <DES><![CDATA[<h4>ST_ExteriorRing( polyg <i>Polygon</i> ) : <i>LineString</i></h4><br>
Returns the ExteriorRing of p. ]]></DES>
</FUNC>

<FUNC caption="ST_NumInteriorRing" code="ST_NumInteriorRing()">
 <DES><![CDATA[<h4>ST_NumInteriorRing( polyg <i>Polygon</i> ) : <i>Integer</i></h4><br>
Returns the number of InteriorRings. ]]></DES>
</FUNC>

<FUNC caption="ST_InteriorRingN" code="ST_InteriorRingN()">
 <DES><![CDATA[<h4>ST_InteriorRingN( polyg <i>Polygon</i> , n <i>Integer</i> ) : <i>LineString</i></h4><br>
Returns the nth InteriorRing. The order of Rings is not geometrically significant. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="23- SQL for GeomCollections" code="">
<DES>SQL functions on type GeomCollection</DES>
<FUNC caption="ST_NumGeometries" code="ST_NumGeometries()">
 <DES><![CDATA[<h4>ST_NumGeometries( geom <i>GeometryCollection</i> ) : <i>Integer</i></h4><br>
Returns the number of individual Geometries. ]]></DES>
</FUNC>

<FUNC caption="ST_GeometryN" code="ST_GeometryN()">
 <DES><![CDATA[<h4>ST_GeometryN( geom <i>GeometryCollection</i> , n <i>Integer</i> ) : <i>Geometry</i></h4><br>
Returns the nth geometric object in the collection. The order of the elements in the collection is not geometrically significant. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="24- SQL for MBR tests" code="">
<DES>SQL functions that test approximate spatial relationships via MBRs</DES>
<FUNC caption="MbrEqual" code="MbrEqual()">
 <DES><![CDATA[<h4>MbrEqual( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if g1 and g2 have equal MBRs. ]]></DES>
</FUNC>

<FUNC caption="MbrDisjoint" code="MbrDisjoint()">
 <DES><![CDATA[<h4>MbrDisjoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if the intersection of g1 and g2 MBRs is the empty set. ]]></DES>
</FUNC>

<FUNC caption="MbrTouches" code="MbrTouches()">
 <DES><![CDATA[<h4>MbrTouches( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if the only Points in common between g1 and g2 MBRs lie in <br>
 the union of the boundaries of g1 and g2. ]]></DES>
</FUNC>

<FUNC caption="MbrWithin" code="MbrWithin()">
 <DES><![CDATA[<h4>MbrWithin( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if g1 MBR is completely contained in g2 MBR. ]]></DES>
</FUNC>

<FUNC caption="MbrOverlaps" code="MbrOverlaps()">
 <DES><![CDATA[<h4>MbrOverlaps( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if the intersection of g1 and g2 MBRs results in a value of the <br>
 same dimension as g1 and g2 that is different from both g1 and g2. ]]></DES>
</FUNC>

<FUNC caption="MbrIntersects" code="MbrIntersects()">
 <DES><![CDATA[<h4>MbrIntersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments; convenience predicate: <br>
 TRUE if the intersection of g1 and g2 MBRs is not empty. ]]></DES>
</FUNC>

<FUNC caption="ST_EnvIntersects" code="ST_EnvIntersects()">
 <DES><![CDATA[<h4>ST_EnvIntersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i>   <br>
 ST_EnvIntersects( geom1 <i>Geometry</i> , x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> ) : <i>Integer</i></h4><br>
The first form simply is an alias name for MbrIntersects; the other form allows to define the second <br>
 MBR by two extreme points [x1, y1] and [x2, y2]. The return type is Integer, <br>
 with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN corresponding <br>
 to a function invocation on invalid arguments; convenience predicate: <br>
 TRUE if the intersection of both MBRs is not empty. ]]></DES>
</FUNC>

<FUNC caption="MbrContains" code="MbrContains()">
 <DES><![CDATA[<h4>MbrContains( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments;   <br>
 convenience predicate: TRUE if g2 MBR is completely contained in g1 MBR. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="25- Spatial Relationships" code="">
<DES>SQL functions that test spatial relationships</DES>
<FUNC caption="ST_Equals" code="ST_Equals()">
 <DES><![CDATA[<h4>ST_Equals( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if g1 and g2 are equal. ]]></DES>
</FUNC>

<FUNC caption="ST_Disjoint" code="ST_Disjoint()">
 <DES><![CDATA[<h4>ST_Disjoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if the intersection of g1 and g2 is the empty set. ]]></DES>
</FUNC>

<FUNC caption="ST_Touches" code="ST_Touches()">
 <DES><![CDATA[<h4>ST_Touches( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if the only Points in common between g1 and g2 lie in the union <br>
 of the boundaries of g1 and g2. ]]></DES>
</FUNC>

<FUNC caption="ST_Within" code="ST_Within()">
 <DES><![CDATA[<h4>ST_Within( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if g1 is completely contained in g2. ]]></DES>
</FUNC>

<FUNC caption="ST_Overlaps" code="ST_Overlaps()">
 <DES><![CDATA[<h4>ST_Overlaps( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if the intersection of g1 and g2 results in a value of the same <br>
 dimension as g1 and g2 that is different from both g1 and g2. ]]></DES>
</FUNC>

<FUNC caption="ST_Crosses" code="ST_Crosses()">
 <DES><![CDATA[<h4>ST_Crosses( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments.   <br>
 TRUE if the intersection of g1 and g2 results in a value whose dimension <br>
 is less than the maximum dimension of g1 and g2 and the intersection value <br>
 includes Points interior to both g1 and g2, and the intersection value is <br>
 not equal to either g1 or g2. ]]></DES>
</FUNC>

<FUNC caption="ST_Intersects" code="ST_Intersects()">
 <DES><![CDATA[<h4>ST_Intersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments; convenience predicate: <br>
 TRUE if the intersection of g1 and g2 is not empty. ]]></DES>
</FUNC>

<FUNC caption="ST_Contains" code="ST_Contains()">
 <DES><![CDATA[<h4>ST_Contains( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments;   <br>
 convenience predicate: TRUE if g2 is completely contained in g1. ]]></DES>
</FUNC>

<FUNC caption="ST_Covers" code="ST_Covers()">
 <DES><![CDATA[<h4>ST_Covers( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments;   <br>
 convenience predicate: TRUE if g1 completely covers g2, ]]></DES>
</FUNC>

<FUNC caption="ST_CoveredBy" code="ST_CoveredBy()">
 <DES><![CDATA[<h4>ST_CoveredBy( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments;   <br>
 convenience predicate: TRUE if g1 is completely covered by g2. ]]></DES>
</FUNC>

<FUNC caption="ST_Relate" code="ST_Relate()">
 <DES><![CDATA[<h4>ST_Relate( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , patternMatrix <i>String</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments;   <br>
 returns TRUE if the spatial relationship specified by the patternMatrix holds. ]]></DES>
</FUNC>

</GROUP>
<GROUP caption="26- Distance relationships" code="">
<FUNC caption="ST_Distance" code="ST_Distance()">
 <DES><![CDATA[<h4>ST_Distance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></h4><br>
Returns the distance between geom1 and geom2 (always measured in CRS units). ]]></DES>
</FUNC>
<FUNC caption="PtDistWithin" code="PtDistWithin()">
 <DES><![CDATA[<h4>PtDistWithin( geom1 <i>Geometry</i> , geom2 <i>Geometry</i>, range <i>Double precision</i> [, use_spheroid <i>Integer</i> ] ) : <i>Integer</i></h4><br>
Returns TRUE (1) if the distance between geom1 and geom2 is within the given range. <br>
 Usually distances are expressed in the length unit corresponding to the <br>
 geoms own SRID: but if both geoms are simple POINTs and their SRID is 4326 <br>
 (i.e. WGS84), then distances are expressed in meters. In this later case the <br>
 optional arg use_spheroid can be used to select the distance algorithm to be <br>
 used: is use_spheroid = 1 the slowest but most accurate geodesic distance will <br>
 be evaluated: in any other case the simplest great circle distance will be used instead. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="27- Spatial Operators" code="">
<DES>SQL functions that implement spatial operators</DES>
<FUNC caption="ST_Intersection" code="ST_Intersection()">
 <DES><![CDATA[<h4>ST_Intersection( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object that is the intersection of geometric objects geom1 and geom2. ]]></DES>
</FUNC>

<FUNC caption="ST_Difference" code="ST_Difference()">
 <DES><![CDATA[<h4>ST_Difference( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object that is the closure of the set difference of geom1 and geom2. ]]></DES>
</FUNC>

<FUNC caption="ST_Union" code="ST_Union()">
 <DES><![CDATA[<h4>ST_Union( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object that is the set union of input values. <br>
Aggregate function. ]]></DES>
</FUNC>

<FUNC caption="ST_SymDifference" code="ST_SymDifference()">
 <DES><![CDATA[<h4>ST_SymDifference( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object that is the closure of the set symmetric difference of geom1 and geom2 (logical XOR of space). ]]></DES>
</FUNC>

<FUNC caption="ST_Buffer" code="ST_Buffer()">
 <DES><![CDATA[<h4>ST_Buffer( geom <i>Geometry</i> , dist <i>Double precision</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object defined by buffering a distance d around geom, <br>
 where dist is in the distance units for the Spatial Reference of geom. ]]></DES>
</FUNC>

<FUNC caption="ST_ConvexHull" code="ST_ConvexHull()">
 <DES><![CDATA[<h4>ST_ConvexHull( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object that is the convex hull of geom. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="28- GEOS Operators" code="">
<DES>SQL functions that implement spatial operators [GEOS specific features]</DES>
<FUNC caption="ST_HausdorffDistance" code="ST_HausdorffDistance()">
 <DES><![CDATA[<h4>ST_HausdorffDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></h4><br>
Returns the Hausdorff distance between geom1 and geom2. ]]></DES>
</FUNC>

<FUNC caption="ST_OffsetCurve" code="ST_OffsetCurve()">
 <DES><![CDATA[<h4>ST_OffsetCurve( geom <i>Curve</i>, radius <i>Double precision</i> , left_or_right <i>Integer</i> ) : <i>Curve</i></h4><br>
Returns a geometric object representing the corresponding left- (positive) or right-sided<br>
(negative) offset curve. Negative offset gives line with opposite direction.<br>
 NULL is returned whenever is not possible deriving an offset curve from the <br>
 original geometry [a single not-closed LINESTRING is expected as input]. ]]></DES>
</FUNC>

<FUNC caption="ST_SingleSidedBuffer" code="ST_SingleSidedBuffer()">
 <DES><![CDATA[<h4>ST_SingleSidedBuffer( geom <i>Curve</i> , radius <i>Double precision</i> , left_or_right <i>Integer</i> ) : <i>Curve</i></h4><br>
Returns a geometric object representing the corresponding left- (or right-sided <br>
if negative) single-sided buffer. <br>
 NULL is returned whenever is not possible deriving a single-sided buffer <br>
 from the original geometry [a single not-closed LINESTRING is expected as input]. ]]></DES>
</FUNC>

<FUNC caption="ST_SharedPaths" code="ST_SharedPaths()">
 <DES><![CDATA[<h4>ST_SharedPaths( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object (of the MULTILINESTRING type) representing any common lines shared by both geometries. <br>
 NULL is returned is no common line exists. ]]></DES>
</FUNC>

<FUNC caption="ST_Line_Interpolate_Point" code="ST_Line_Interpolate_Point()">
 <DES><![CDATA[<h4>ST_Line_Interpolate_Point( line <i>Curve</i> , fraction <i>Double precision</i> ) : <i>Point</i></h4><br>
Returns a point interpolated along a line. Second argument (between 0.0 and 1.0) <br>
 representing fraction of total length of linestring the point has to be located. <br>
 NULL is returned for invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="ST_Line_Interpolate_Equidistant_Points" code="ST_Line_Interpolate_Equidistant_Points()">
 <DES><![CDATA[<h4>ST_Line_Interpolate_Equidistant_Points( line <i>Curve</i> , distance <i>Double precision</i> ) : <i>MultiPoint</i></h4><br>
Returns a set of equidistant points interpolated along a line; <br>
 the returned geometry always corresponds to a MULTIPOINT supporting the M coordinate <br>
 (representing the progressive distance for each interpolated Point). <br>
 Second argument represents the regular distance between interpolated points. <br>
 NULL is returned for invalid arguments
. ]]></DES>
</FUNC>

<FUNC caption="ST_Line_Locate_Point" code="ST_Line_Locate_Point()">
 <DES><![CDATA[<h4>ST_Line_Locate_Point( line <i>Curve</i> , point <i>Point</i> ) : <i>Double precision</i></h4><br>
Returns a number (between 0.0 and 1.0) representing the location of the closest point on <br>
 LineString to the given Point, as a fraction of total 2d line length. <br>
 NULL is returned for invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="ST_Line_Substring" code="ST_Line_Substring()">
 <DES><![CDATA[<h4>ST_Line_Substring( line <i>Curve</i> , start_fraction <i>Double precision</i> , end_fraction <i>Double precision</i> ) : <i>Curve</i></h4><br>
Return a Linestring being a substring of the input one starting and ending at the given fractions of total 2d length. <br>
 Second and third arguments are expected to be in the range between 0.0 and 1.0. <br>
 NULL is returned for invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="ST_ClosestPoint" code="ST_ClosestPoint()">
 <DES><![CDATA[<h4>ST_ClosestPoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Point</i></h4><br>
Returns the Point on geom1 that is closest to geom2. <br>
 NULL is returned for invalid arguments (or if distance is ZERO). ]]></DES>
</FUNC>

<FUNC caption="ST_ShortestLine" code="ST_ShortestLine()">
 <DES><![CDATA[<h4>ST_ShortestLine( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Curve</i></h4><br>
Returns the shortest line between two geometries. <br>
 NULL is returned for invalid arguments (or if distance is ZERO). ]]></DES>
</FUNC>

<FUNC caption="ST_Snap" code="ST_Snap()">
 <DES><![CDATA[<h4>ST_Snap( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Geometry</i></h4><br>
"Returns a new Geometry representing a modified geom1, so to ""snap"" vertices and <br>
 segments to geom2 vertices; a snap distance tolerance is used to <br>
 control where snapping is performed. ]]></DES>
</FUNC>

<FUNC caption="ST_Collect" code="ST_Collect()">
 <DES><![CDATA[<h4>ST_Collect( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><br>
 ST_Collect( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
A generic Geometry (possibly a GEOMETRYCOLLECTION) will be returned merging geom1 and geom2   <br>
 NULL will be returned if any error is encountered. <br>
 OR: a generic Geometry (possibly a GEOMETRYCOLLECTION) will be returned <br>
 merging input Geometries all together. <br>
 Aggregate function   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_LineMerge" code="ST_LineMerge()">
 <DES><![CDATA[<h4>ST_LineMerge( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
a Geometry (actually corresponding to a LINESTRING or MULTILINESTRING) will be returned. <br>
 The input Geometry is expected to represent a LINESTRING or a MULTILINESTRING. <br>
 The input Geometry can be an arbitrary collection of sparse line fragments: <br>
 this function will then try to (possibly) reassemble them into one (or more) Linestring(s).   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_BuildArea" code="ST_BuildArea()">
 <DES><![CDATA[<h4>ST_BuildArea( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
a Geometry (actually corresponding to a POLYGON or MULTIPOLYGON) will be returned. <br>
 The input Geometry is expected to represent a LINESTRING or a MULTILINESTRING. <br>
 The input Geometry can be an arbitrary collection of sparse Linestrings: <br>
 this function will then try to (possibly) reassemble them into one (or more) polygon(s).   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_Polygonize" code="ST_Polygonize()">
 <DES><![CDATA[<h4>ST_Polygonize( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Exactly the same as ST_BuildArea, but implemented as an aggregate function.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_MakePolygon" code="ST_MakePolygon()">
 <DES><![CDATA[<h4>ST_MakePolygon( geom1 <i>Geometry</i> [ , geom2 <i>Geometry</i> ] ) : <i>Geometry</i></h4><br>
Kind of lightweight/simplified ST_BuildArea: the first input Geometry is always expected to represent a closed <br>
 LINESTRING assumed to identify the output polygon's Exterior Ring. <br>
 The second input Geometry (if any) is expected to be a LINESTRING or <br>
 MULTILINESTRING identifying any polygon's Interior Ring (and all them are <br>
 expected to be correctly closed). Please note well: this function doesn't <br>
 perform any internal topology check, so it could possibly return an invalid <br>
 polygon on invalid input.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_UnaryUnion" code="ST_UnaryUnion()">
 <DES><![CDATA[<h4>ST_UnaryUnion( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Exactely the same as ST_Union, but applied to a single Geometry. <br>
 (set union of elementary Geometries within a MULTI- or GEOMETRYCOLLECTION complex Geometry)   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_DissolveSegments" code="ST_DissolveSegments()">
 <DES><![CDATA[<h4>ST_DissolveSegments( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
A Geometry (actually corresponding to a LINESTRING, MULTILINESTRING or GEOMETRYCOLLECTION) <br>
 will be returned. The input Geometry is arbitrary: any POINT will remain <br>
 unaffected, but any LINESTRING or RING will be dissolved into elementary segments.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_DissolvePoints" code="ST_DissolvePoints()">
 <DES><![CDATA[<h4>ST_DissolvePoints( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
A Geometry (actually corresponding to a POINT or MULTIPOINT) will be returned. <br>
 The input Geometry is arbitrary: any POINT will remain unaffected, <br>
 but any LINESTRING or RING will be dissolved into elementary Points <br>
 corresponding to each Vertex.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_LinesFromRings" code="ST_LinesFromRings()">
 <DES><![CDATA[<h4>ST_LinesFromRings( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
a Geometry (actually corresponding to a LINESTRING or MULTILINESTRING) will be returned. <br>
 The input Geometry is expected to be a POLYGON or MULTIPOLYGON; <br>
 any RING will then be transformed into the corresponding LINESTRING.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_LinesCutAtNodes" code="ST_LinesCutAtNodes()">
 <DES><![CDATA[<h4>ST_LinesCutAtNodes( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></h4><br>
a Geometry (actually corresponding to a LINESTRING or MULTILINESTRING) will be returned. <br>
 The first input Geometry is expected to be a LINESTRING or MULTILINESTRING<br>
 (Lines); the second input Geometry is expected to be a POINT or MULTIPOINT<br>
 (Nodes). Any Line will then be possibly split in two halves where some <br>
 vertex exactly intercepts a Node.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_RingsCutAtNodes" code="ST_RingsCutAtNodes()">
 <DES><![CDATA[<h4>ST_RingsCutAtNodes( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
a Geometry (actually corresponding to a LINESTRING or MULTILINESTRING) will be returned. <br>
 The input Geometry is expected to be a POLYGON or MULTIPOLYGON (Rings); <br>
 any self-intersection or intersection between Rings is assumed to <br>
 represent a Node. Any Ring will then be possibly split in two halves <br>
 where some vertex exactly intercepts a Node.   <br>
 NULL will be returned if any error is encountered. ]]></DES>
</FUNC>

<FUNC caption="ST_CollectionExtract" code="ST_CollectionExtract()">
 <DES><![CDATA[<h4>ST_CollectionExtract( geom <i>Geometry</i> , type <i>Integer</i> ) : <i>Geometry</i></h4><br>
Given any arbitrary GEOMETRY will return a derived geometry consisting only of the specified type. <br>
 Sub-geometries that are not the specified type are ignored. <br>
 1 = POINT-type 2 = LINESTRING-type 3 = POLYGON-type <br>
 NULL will be returned if any error is encountered (or when no item of <br>
 required type is found) The Type of the returned Geometry could be e.g. <br>
 POINT or MULTIPOINT depending on actual items count. ]]></DES>
</FUNC>

<FUNC caption="ExtractMultiPoint" code="ExtractMultiPoint()">
 <DES><![CDATA[<h4>ExtractMultiPoint( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Given any arbitrary GEOMETRY will return a derived MULTIPOINT geometry. <br>
 Sub-geometries not being of the POINT type will be ignored. <br>
 NULL will be returned if any error is encountered <br>
 (or when no POINT is found). ]]></DES>
</FUNC>

<FUNC caption="ExtractMultiLinestring" code="ExtractMultiLinestring()">
 <DES><![CDATA[<h4>ExtractMultiLineString( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Given any arbitrary GEOMETRY will return a derived MULTILINESTRING geometry. <br>
 Sub-geometries not being of the LINESTRING type will be ignored. <br>
 NULL will be returned if any error is encountered <br>
 (or when no LINESTRING is found). ]]></DES>
</FUNC>

<FUNC caption="ExtractMultiPolygon" code="ExtractMultiPolygon()">
 <DES><![CDATA[<h4>ExtractMultiPolygon>( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Given any arbitrary GEOMETRY will return a derived MULTIPOLYGON geometry. <br>
 Sub-geometries not being of the POLYGON type will be ignored. <br>
 NULL will be returned if any error is encountered <br>
 (or when no POLYGON is found). ]]></DES>
</FUNC>

<FUNC caption="ST_LocateAlongMeasure" code="ST_LocateAlongMeasure()">
 <DES><![CDATA[<h4>ST_Locate_Along_Measure( geom <i>Geometry</i> , m_value <i>Double precision</i> ) : <i>Geometry</i></h4><br>
Return a derived geometry collection value with elements that match the specified measure. <br>
 NULL will be returned if any error is encountered <br>
 (or when no element corresponding to the given measure is found). <br>
 Please note: NULL will be returned if geom doesn't contain M-dimension, <br>
 or if geom contains a Polygon, or if geom is a GeometryCollection. ]]></DES>
</FUNC>

<FUNC caption="ST_LocateBetweenMeasures" code="ST_LocateBetweenMeasures()">
 <DES><![CDATA[<h4>ST_Locate_Between_Measures( geom <i>Geometry</i> , m_start <i>Double precision</i> , m_end <i>Double precision</i> ) : <i>Geometry</i></h4><br>
Return a derived geometry collection value with elements that match the specified range of measures. <br>
 NULL will be returned if any error is encountered <br>
 (or when no element corresponding to the given range of measures is found). <br>
 Please note: NULL will be returned if geom doesn't contain M-dimension, <br>
 or if geom contains a Polygon, or if geom is a GeometryCollection. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="29- GEOS Advanced" code="">
<DES>SQL functions that implement spatial operators [GEOS advanced features]</DES>
<FUNC caption="ST_DelaunayTriangulation" code="ST_DelaunayTriangulation()">
 <DES><![CDATA[<h4>DelaunayTriangulation( geom <i>Geometry</i> [ , edges_only <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ) : <i>Geometry</i>  <br>
 ST_DelaunayTriangulation( geom <i>Geometry</i> [ , edges_only <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ) : <i>Geometry</i></h4><br>
Returns a geometric object representing the Delaunay Triangulation corresponding to the input Geometry. <br>
 The input Geometry could have any arbitrary type; eventually <br>
 all Linestring's / Polygon's vertices will be dissolved into Points, <br>
 so to implicitly always get a MultiPoint. The returned Geometry will <br>
 usually be of the MultiPolygon type (a collection of Triangles), but <br>
 will be a MultiLinestring if the optional edges_only argument is set to <br>
 TRUE The optional argument tolerance is intended to normalize the input <br>
 Geometry, suppressing repeated (or too close) Points. <br>
 NULL is returned on failure. ]]></DES>
</FUNC>

<FUNC caption="ST_VoronojDiagram" code="ST_VoronojDiagram()">
 <DES><![CDATA[<h4>VoronojDiagram( geom <i>Geometry</i> [ , edges_only <i>Boolean</i> [ , frame_extra_size <i>Double precision</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i> <br>
 ST_VoronojDiagram( geom <i>Geometry</i> [ , edges_only <i>Boolean</i> [ , frame_extra_size <i>Double precision</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i></h4><br>
return a geometric object representing the Voronoj Diagram corresponding to the input Geometry. <br>
 The input Geometry could have any arbitrary type; eventually all <br>
 Linestring's / Polygon's vertices will be dissolved into Points, <br>
 so to implicitly always get a MultiPoint. The returned Geometry will <br>
 usually be of the MultiPolygon type, but will be a MultiLinestring if <br>
 the optional edges_only argument is set to TRUE The optional argument <br>
 extra_frame_size allows to arbitrarily set the percent extension of the <br>
 bounding frame: the default value is 5%. The optional argument tolerance is <br>
 intended to normalize the input Geometry, suppressing repeated (or too close) Points. <br>
NULL is returned on failure. ]]></DES>
</FUNC>

<FUNC caption="ST_ConcaveHull" code="ST_ConcaveHull()">
 <DES><![CDATA[<h4>ST_ConcaveHull( geom <i>Geometry</i> [ , factor <i>Double precision</i> [ , allow_holes <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i></h4><br>
Returns a geometric object representing the ConcaveHull corresponding to the input Geometry. <br>
 The input Geometry could have any arbitrary type; eventually all <br>
 Linestring's / Polygon's vertices will be dissolved into Points, so to <br>
 implicitly always get a MultiPoint. The returned Geometry will always be <br>
 of the Polygon or MultiPolygon type. The default factor applies a 3σ filtering; <br>
 by declaring some lower factor you can get a more aggressive filtering effect. <br>
 By setting the optional allow_holes argument to TRUE all interior holes will be <br>
 preserved. The optional argument tolerance is intended to normalize the input Geometry, <br>
 suppressing repeated (or too close) Points. <br>
 NULL is returned on failure. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="30- LWGEOM Operators" code="">
<DES>SQL functions that implement spatial operators [LWGEOM features]</DES>
<FUNC caption="ST_MakeValid" code="ST_MakeValid()">
 <DES><![CDATA[<h4>ST_MakeValid( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
return a geometric object representing the repaired version of the input Geometry. <br>
 If the input Geometry was already valid, then it will <br>
 be returned exactly as it was. <br>
 NULL is returned on failure. ]]></DES>
</FUNC>

<FUNC caption="ST_MakeValidDiscarded" code="ST_MakeValidDiscarded()">
 <DES><![CDATA[<h4>ST_MakeValidDiscarded( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
return a geometric object containing all elements that would be eventually discarded <br>
 by ST_MakeValid() while validating the same input Geometry. <br>
 NULL is returned on failure, or if no discarded item exists. ]]></DES>
</FUNC>

<FUNC caption="ST_Segmentize" code="ST_Segmentize()">
 <DES><![CDATA[<h4>ST_Segmentize( geom <i>Geometry</i> , dist <i>Double precision</i> ) : <i>Geometry</i></h4><br>
return a new Geometry corresponding to the input Geometry; as much Linestring / Ring <br>
 vertices as required will be eventually interpolated so to ensure <br>
 that no segment will be longer than dist. <br>
 NULL is returned on failure. ]]></DES>
</FUNC>

<FUNC caption="ST_Split" code="ST_Split()">
 <DES><![CDATA[<h4>ST_Split( geom <i>Geometry</i> , blade <i>Geometry</i> ) : <i>Geometry</i></h4><br>
return a new Geometry collecting all items resulting by splitting the <br>
 input Geometry by the blade. <br>
 NULL is returned on failure. ]]></DES>
</FUNC>

<FUNC caption="ST_SplitLeft" code="ST_SplitLeft()">
 <DES><![CDATA[<h4>ST_SplitLeft( geom <i>Geometry</i> , blade <i>Geometry</i> ) : <i>Geometry</i></h4><br>
return a new Geometry collecting all items resulting by splitting the <br>
 input Geometry by the blade and falling on the left side. <br>
 All items not affected by the split operation (i.e. not intersecting <br>
 the blade) will be returned into the left collection. <br>
 NULL is returned on failure. ]]></DES>
</FUNC>

<FUNC caption="ST_SplitRight" code="ST_SplitRight()">
 <DES><![CDATA[<h4>ST_SplitRight( geom <i>Geometry</i> , blade <i>Geometry</i> ) : <i>Geometry</i></h4><br>
return a new Geometry collecting all items resulting by splitting the <br>
 input Geometry by the blade and falling on the right side. <br>
 NULL is returned on failure (or if the right side is empty). ]]></DES>
</FUNC>

<FUNC caption="ST_Azimuth" code="ST_Azimuth()">
 <DES><![CDATA[<h4>ST_Azimuth( pt1 <i>Geometry</i> , pt2 <i>Geometry</i> ) : <i>Double precision</i></h4><br>
return the angle (in radians) from the horizontal of the vector defined by pt1 and pt2. <br>
 Both pt1 and pt2 are expected to be simple Points. <br>
 Starting since 4.1.0 if both points supports long/lat coords <br>
 the returned Azimuth will be precisely computed on the ellipsoid. <br>
 NULL is returned on failure.   <br>
 On the clock: 12=0; 3=PI/2; 6=PI; 9=3PI/2 ]]></DES>
</FUNC>

<FUNC caption="ST_Project" code="ST_Project()">
 <DES><![CDATA[<h4>ST_Project( start_point <i>Geometry</i>, distance <i>Double precision</i>, azimuth <i>Double precision</i> ) : <i>Geometry</i></h4><br>
return a new Point projected from a start point using a bearing and distance. <br>
 Start_point is expected to be simple long/lat Point. Distance is <br>
 expected to be measured in meters; azimuth in radians(aka bearing or heading) <br>
 has the same identical meaning as in ST_Azimuth(). <br>
 NULL is returned on failure or on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="ST_SnapToGrid" code="ST_SnapToGrid()">
 <DES><![CDATA[<h4>ST_SnapToGrid( geom <i>Geometry</i> , size <i>Double precision</i> ) : <i>Geometry</i> <br>
 ST_SnapToGrid( geom <i>Geometry</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> ) ) : <i>Geometry</i> <br>
 ST_SnapToGrid( geom <i>Geometry</i> , origin_x <i>Double precision</i> , origin_y <i>Double precision</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> ) ) : <i>Geometry</i> <br>
 ST_SnapToGrid( geom <i>Geometry</i> , origin <i>Geometry</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> , size_z <i>Double precision</i> , size_m <i>Double precision</i> ) : <i>Geometry</i></h4><br>
Returns a new Geometry corresponding to the input Geometry; all points and vertices will be snapped <br>
 to the grid defined by its origin and size(s). Removes all consecutive points <br>
 falling on the same cell. All collapsed geometries will be stripped from <br>
 the returned Geometry. <br>
 NULL is returned on failure. ]]></DES>
</FUNC>

<FUNC caption="ST_GeoHash" code="ST_GeoHash()">
 <DES><![CDATA[<h4>GeoHash( geom <i>Geometry</i> ) : <i>String</i>   ST_GeoHash( geom <i>Geometry</i> ) : <i>String</i></h4><br>
Returns a GeoHash representation (geohash.org) of the geometry. <br>
 A GeoHash encodes a point into a text form that is sortable <br>
 and searchable based on prefixing.   ST_GeoHash will not work <br>
 with geometries that are not in geographic (lon/lat) coordinates. ]]></DES>
</FUNC>

<FUNC caption="ST_AsX3D" code="ST_AsX3D()">
 <DES><![CDATA[<h4>ST_AsX3D( geom <i>Geometry</i> ) : <i>String</i> <br>
 ST_AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> ) : <i>String</i> <br>
 ST_AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> , options <i>Integer</i> ) : <i>String</i> <br>
 ST_AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> , options <i>Integer</i> , refid <i>String</i> ) : <i>String</i></h4><br>
Returns a geometry as an X3D XML formatted node element. ]]></DES>
</FUNC>

<FUNC caption="ST_MaxDistance" code="ST_MaxDistance()">
 <DES><![CDATA[<h4>ST_MaxDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></h4><br>
Returns the max distance between geom1 and geom2. ]]></DES>
</FUNC>

<FUNC caption="ST_3DDistance" code="ST_3DDistance()">
 <DES><![CDATA[<h4>ST_3DDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></h4><br>
Returns the 3D-distance between geom1 and geom2 (Z coordinates will be considered). ]]></DES>
</FUNC>

<FUNC caption="ST_3DMaxDistance" code="ST_3DMaxDistance()">
 <DES><![CDATA[<h4>ST_3DMaxDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></h4><br>
Returns the max 3D-distance between geom1 and geom2 (Z coordinates will be considered). ]]></DES>
</FUNC>

<FUNC caption="ST_Node" code="ST_Node()">
 <DES><![CDATA[<h4>ST_Node( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Fully nodes a set of linestrings using the least possible number of <br>
 nodes while preserving all of the input ones. <br>
 NULL will be returned if the input Geometry isn't a set of <br>
 linestrings or if any other error occurs. ]]></DES>
</FUNC>

<FUNC caption="ST_SelfIntersections" code="ST_SelfIntersections()">
 <DES><![CDATA[<h4>ST_SelfIntersections( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a MultiPoint Geometry representing any self-intersection found within the <br>
 input geometry [expected to be of the Linestring or MultiLinestring type]. <br>
 NULL will be returned for invalid arguments, or when no self-intersections were found. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="31- Coord Transformations" code="">
<DES>SQL functions for coordinate transformations</DES>
<FUNC caption="ST_Transform" code="ST_Transform()">
 <DES><![CDATA[<h4>ST_Transform( geom <i>Geometry</i> , newSRID <i>Integer</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object obtained by reprojecting coordinates into the Reference System identified by newSRID. ]]></DES>
</FUNC>

<FUNC caption="SridFromAuthCRS" code="SridFromAuthCRS()">
 <DES><![CDATA[<h4>SridFromAuthCRS( auth_name <i>String</i> , auth_SRID <i>Integer</i> ) : <i>Integer</i></h4><br>
Returns the internal SRID corresponding to auth_name and auth_SRID -1 will be returned if no such CRS is defined. ]]></DES>
</FUNC>

<FUNC caption="ShiftCoords" code="ShiftCoords()">
 <DES><![CDATA[<h4>ShiftCoords( geom <i>Geometry</i> , shiftX <i>Double precision</i> , shiftY <i>Double precision</i> ) : <i>Geometry</i>  <br>
 ShiftCoordinates( geom <i>Geometry</i> , shiftX <i>Double precision</i> , shiftY <i>Double precision</i> ) : <i>Geometry</i></h4><br>
return a geometric object obtained by translating coordinates according to shiftX and shiftY values. ]]></DES>
</FUNC>

<FUNC caption="ST_Translate" code="ST_Translate()">
 <DES><![CDATA[<h4>ST_Translate( geom <i>Geometry</i> , shiftX <i>Double precision</i> , shiftY <i>Double precision</i> , shiftZ <i>Double precision</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object obtained by translating coordinates according to shiftX, shiftY and shiftZ values. ]]></DES>
</FUNC>

<FUNC caption="ST_Shift_Longitude" code="ST_Shift_Longitude()">
 <DES><![CDATA[<h4>ST_Shift_Longitude( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object obtained by translating any negative longitude by 360.   <br>
 Only meaningful for geographic (longitude/latitude) coordinates. <br>
 Negative longitudes (-180/0) will be shifted by 360, thus allowing to <br>
 represent longitudes in the 0/360 range and effectively crossing the <br>
 International Date Line. ]]></DES>
</FUNC>

<FUNC caption="NormalizeLonLat" code="NormalizeLonLat()">
 <DES><![CDATA[<h4>NormalizeLonLat( geom <i>Geometry</i> ) : <i>Geometry</i></h4><br>
Returns a geometric object obtained by normalizing any longitude in the <br>
 range [-180 / +180] and any latitude in the range [-90 / + 90].   <br>
 Only meaningful for geographic (longitude/latitude) coordinates. ]]></DES>
</FUNC>

<FUNC caption="ScaleCoords ScaleCoordinates" code="ScaleCoords ScaleCoordinates()">
 <DES><![CDATA[<h4>ScaleCoords( geom <i>Geometry</i> , scaleX <i>Double precision</i> [ , scaleY <i>Double precision</i> ] ) : <i>Geometry</i>   <br>
 ScaleCoordinates( geom <i>Geometry</i> , scaleX <i>Double precision</i> [ , scaleY <i>Double precision</i> ] ) : <i>Geometry</i></h4><br>
Returns a geometric object obtained by scaling coordinates according to scaleX and scaleY values  <br>
 if only one scale factor is specified, then an isotropic scaling occurs <br>
 [i.e. the same scale factor is applied to both axis] otherwise an anisotropic <br>
 scaling occurs [i.e. each axis is scaled according to its own scale factor]. ]]></DES>
</FUNC>

<FUNC caption="RotateCoords" code="RotateCoords()">
 <DES><![CDATA[<h4>RotateCoords( geom <i>Geometry</i> , angleInDegrees <i>Double precision</i> ) : <i>Geometry</i>  </h4><br>
Returns a geometric object obtained by rotating coordinates according <br>
 to angleInDegrees value.   Positive angle = clockwise rotation. <br>
 Negative angle = counterclockwise rotation. ]]></DES>
</FUNC>

<FUNC caption="ReflectCoords" code="ReflectCoords()">
 <DES><![CDATA[<h4>ReflectCoords( geom <i>Geometry</i> , xAxis <i>Integer</i> , yAxis <i>Integer</i> ) : <i>Geometry</i>  </h4><br>
return a geometric object obtained by reflecting coordinates according to xAxis and yAxis switches  <br>
 i.e. if xAxis is 0 (FALSE), then x-coordinates remains untouched; <br>
 otherwise x-coordinates will be reflected. ]]></DES>
</FUNC>

<FUNC caption="SwapCoords" code="SwapCoords()">
 <DES><![CDATA[<h4>SwapCoords( geom <i>Geometry</i> ) : <i>Geometry</i>   </h4><br>
Returns a geometric object obtained by swapping x- and y-coordinates. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="32- Spatial-MetaData" code="">
<DES>SQL functions for Spatial-MetaData and Spatial-Index handling</DES>
<FUNC caption="InitSpatialMetaData" code="InitSpatialMetaData()">
 <DES><![CDATA[<h4>InitSpatialMetaData( <i>void</i> ) : <i>Integer</i>   <br>
 InitSpatialMetaData( transaction <i>Integer</i> ) : <i>Integer</i>   <br>
 InitSpatialMetaData( mode <i>String</i> ) : <i>Integer</i>   <br>
 InitSpatialMetaData( transaction <i>Integer</i> , mode <i>String</i> ) : <i>Integer</i></h4><br>
Creates the geometry_columns and spatial_ref_sys metadata tables.  <br>
 The return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<br>
 if the optional argument transaction is set to TRUE the whole operation will<br>
 be handled as a single Transaction (faster): the default setting is <br>
 transaction=FALSE (slower, but safer). if the optional argument mode <br>
 is not specified then any possible ESPG SRID definition will be inserted <br>
 into the spatial_ref_sys table. if the mode arg 'WGS84' (alias 'WGS84_ONLY') <br>
 is specified, then only WGS84-related EPSG SRIDs will be inserted if the mode <br>
 arg 'NONE' (alias 'EMPTY') is specified, no EPSG SRID will be inserted at all. ]]></DES>
</FUNC>

<FUNC caption="InsertEpsgSrid" code="InsertEpsgSrid()">
 <DES><![CDATA[<h4>InsertEpsgSrid( srid <i>Integer</i> ) : <i>Integer</i></h4><br>
Attempts to insert into spatial_ref_sys the EPSG definition uniquely identified <br>
 by srid [the corresponding EPSG SRID definition will be copied from <br>
 the inlined dataset defined in libspatialite]   the return type is Integer, <br>
 with a return value of 1 for success or 0 for failure. ]]></DES>
</FUNC>

<FUNC caption="AddGeometryColumn" code="AddGeometryColumn()">
 <DES><![CDATA[<h4>AddGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> , geom_type <i>String</i> [ , dimension <i>String</i> [ , not_null <i>Integer</i> ] ] ) : <i>Integer</i></h4><br>
Creates a new geometry column updating the Spatial Metadata tables and creating any required <br>
 trigger in order to enforce constraints   <br>
 geom_type has to be one of the followings: <br>
 'POINT', 'POINTZ', 'POINTM', 'POINTZM' <br>
 'LINESTRING', 'LINESTRINGZ', 'LINESTRINGM', 'LINESTRINGZM' <br>
 'POLYGON', 'POLYGONZ', 'POLYGONM', 'POLYGONZM' <br>
 'MULTIPOINT', 'MULTIPOINTZ', 'MULTIPOINTM', 'MULTIPOINTZM' <br>
 'MULTILINESTRING', 'MULTILINESTRINGZ', 'MULTILINESTRINGM', 'MULTILINESTRINGZM' <br>
 'MULTIPOLYGON', 'MULTIPOLYGONZ', 'MULTIPOLYGONM', 'MULTIPOLYGONZM' <br>
 'GEOMETRYCOLLECTION', 'GEOMETRYCOLLECTIONZ', 'GEOMETRYCOLLECTIONZM', 'GEOMETRYCOLLECTIONZM' <br>
 'GEOMETRY', 'GEOMETRYZ', 'GEOMETRYM', 'GEOMETRYZM' <br>
 dimension has to be one of the followings:  <br>
 'XY' or 2: 2D points, identified by X and Y coordinates <br>
 'XYM': 2D points, identified by X and Y coordinates. <br>
 Each point stores an M-value (measure) as well 'XYZ' or 3: <br>
 3D points, identified by X, Y and Z coordinates 'XYZM' or 4: <br>
 3D points, identified by X, Y and Z coordinates. Each point <br>
 stores an M-value (measure) as well Please note: the dimension <br>
 argument is optional; anyway, if specified, iy's expected to be <br>
 consistent with the declared geom_type   the return type is Integer, <br>
 with a return value of 1 for TRUE or 0 for FALSE   the optional 6th arg <br>
 [not_null] is a non-standard extension required by the peculiar SQLite <br>
 arch: if set to 0 [false], then the Geometry column will accept NULL values <br>
 as well. This is the default behaviour if set to any <> 0 value [true], <br>
 then the Geometry will be defined using a NOT NULL clause. ]]></DES>
</FUNC>

<FUNC caption="RecoverGeometryColumn" code="RecoverGeometryColumn()">
 <DES><![CDATA[<h4>RecoverGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> , geom_type <i>String</i> [ , dimension <i>Integer</i> ] ) : <i>Integer</i></h4><br>
Validates an existing ordinary column in order to possibly transform it in a real <br>
 geometry column, thus updating the Spatial Metadata tables and creating any <br>
 required trigger in order to enforce constraints   the return type is Integer, <br>
 with a return value of 1 for TRUE or 0 for FALSE. ]]></DES>
</FUNC>

<FUNC caption="DiscardGeometryColumn" code="DiscardGeometryColumn()">
 <DES><![CDATA[<h4>DiscardGeometryColumn( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></h4><br>
Removes a geometry column from Spatial MetaData tables and drops any related trigger the column itself <br>
 still continues to exist untouched as an ordinary, unconstrained column   the <br>
 return type is Integer, with a return value of 1 for TRUE or 0 for FALSE. ]]></DES>
</FUNC>

<FUNC caption="RegisterVirtualGeometry" code="RegisterVirtualGeometry()">
 <DES><![CDATA[<h4>RegisterVirtualGeometry( table <i>String</i> ) : <i>Integer</i></h4><br>
Registers a VirtualShape table into Spatial MetaData tables; the VirtualShape table should be <br>
 previously created by invoking CREATE VIRTUAL TABLE ... USING VirtualShape(...)  <br>
 the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE. ]]></DES>
</FUNC>

<FUNC caption="DropVirtualGeometry" code="DropVirtualGeometry()">
 <DES><![CDATA[<h4>DropVirtualGeometry( table <i>String</i> ) : <i>Integer</i></h4><br>
Removes a VirtualShape table from Spatial MetaData tables, dropping the VirtualShape table as well.   <br>
 The return type is Integer, with a return value of 1 for TRUE or 0 for FALSE. ]]></DES>
</FUNC>

<FUNC caption="CreateSpatialIndex" code="CreateSpatialIndex()">
 <DES><![CDATA[<h4>CreateSpatialIndex( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></h4><br>
Builds an RTree Spatial Index on a geometry column, creating any required trigger <br>
 required in order to enforce full data coherency between the main table and <br>
 Spatial Index   the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<br>
 -1 will be returned if any physical column named ""rowid"" (caseless) <br>
 shadowing the real ROWID is detected. ]]></DES>
</FUNC>

<FUNC caption="CreateMbrCache" code="CreateMbrCache()">
 <DES><![CDATA[<h4>CreateMbrCache( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></h4><br>
Builds an MbrCache on a geometry column, creating any required trigger required in order to enforce <br>
 full data coherency between the main table and the MbrCache   the return type is <br>
 Integer, with a return value of 1 for TRUE or 0 for FALSE. ]]></DES>
</FUNC>

<FUNC caption="DisableSpatialIndex" code="DisableSpatialIndex()">
 <DES><![CDATA[<h4>DisableSpatialIndex( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></h4><br>
Disables an RTree Spatial Index or MbrCache, removing any related trigger   <br>
 the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE. ]]></DES>
</FUNC>

<FUNC caption="CheckShadowedRowid" code="CheckShadowedRowid()">
 <DES><![CDATA[<h4>CheckShadowedRowid( table <i>String</i> ) : <i>Integer</i></h4><br>
"Checks if some table has a physical column named ""rowid"" (caseless) shadowing the real ROWID. ]]></DES>
</FUNC>

<FUNC caption="CheckWithoutRowid" code="CheckWithoutRowid()">
 <DES><![CDATA[<h4>CheckWithoutRowid( table <i>String</i> ) : <i>Integer</i></h4><br>
Checks if some table was created by specifying a WITHOUT ROWID clause.   <br>
 The return type is Integer, with a return value of 1 for TRUE or 0 for FALSE NULL will be returned if the requested table doesn't exist. ]]></DES>
</FUNC>

<FUNC caption="CheckSpatialIndex" code="CheckSpatialIndex()">
 <DES><![CDATA[<h4>CheckSpatialIndex( <i>void</i> ) : <i>Integer</i>  <br>
 CheckSpatialIndex( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></h4><br>
Checks an RTree Spatial Index for validity and consistency  <br>
 if no arguments are passed, then any RTree defined into geometry_columns will be checked <br>
 otherwise only the RTree corresponding to table and column will be checked  <br>
 the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE <br>
 NULL will be returned if the requested RTree doesn't exist   <br>
 -1 will be returned if any physical column named ""rowid"" (caseless) <br>
 shadowing the real ROWID is detected. ]]></DES>
</FUNC>

<FUNC caption="RecoverSpatialIndex" code="RecoverSpatialIndex()">
 <DES><![CDATA[<h4>RecoverSpatialIndex( [ no_check : <i>Integer</i> ] ) : <i>Integer</i>   <br>
 RecoverSpatialIndex( table <i>String</i> , column <i>String</i> [ , no_check : <i>Integer</i> ] ) : <i>Integer</i></h4><br>
Recovers a (possibly broken) RTree Spatial Index  if no arguments are passed, <br>
 then any RTree defined into geometry_columns will be recovered otherwise only the <br>
 RTree corresponding to table and column will be recovered the optional argument <br>
 no_check will be interpreted as follows:  if no_check = FALSE (default) the RTree <br>
 will be checked first: and only an invalid RTree will be then actually rebuilt if <br>
 no_check = TRUE the RTree will be unconditionally rebuilt from scratch  the return type <br>
 is Integer, with a return value of 1 for TRUE or 0 for FALSE NULL will be returned if the <br>
 requested RTree doesn't exist   -1 will be returned if any physical column named ""rowid"" <br>
 (caseless) shadowing the real ROWID is detected. ]]></DES>
</FUNC>

<FUNC caption="InvalidateLayerStatistics" code="InvalidateLayerStatistics()">
 <DES><![CDATA[<h4>InvalidateLayerStatistics( [ <i>void</i> ) : <i>Integer</i>   <br>
 InvalidateLayerStatistics( table <i>String</i> [ , column <i>String</i> ] ) : <i>Integer</i></h4><br>
Immediately and unconditionally invalidates the internal Layer Statistics <br>
 If no arguments are passed, then internal statistics will be invalidated for any <br>
 possible Geometry Column defined in the current DB otherwise statistics will be updated <br>
 only for Geometry Columns corresponding to the given table  the return type is Integer, <br>
 with a return value of 1 for TRUE or 0 for FALSE   Please note: will effectively work only on <br>
 behalf DB-files supporting the more recent metatables layout introduced starting since version 4.x; <br>
 in any other case will always return an error and no action will happen. ]]></DES>
</FUNC>

<FUNC caption="UpdateLayerStatistics" code="UpdateLayerStatistics()">
 <DES><![CDATA[<h4>UpdateLayerStatistics( <i>void</i> ) : <i>Integer</i>   <br>
 UpdateLayerStatistics( table <i>String</i> [ , column <i>String</i> ] ) : <i>Integer</i></h4><br>
Updates the internal Layer Statistics [Feature Count and Total Extent] <br>
 if no arguments are passed, then internal statistics will be updated for any<br>
 possible Geometry Column defined in the current DB otherwise statistics will <br>
 be updated only for Geometry Columns corresponding to the given table  the return <br>
 type is Integer, with a return value of 1 for TRUE or 0 for FALSE. ]]></DES>
</FUNC>

<FUNC caption="GetLayerExtent" code="GetLayerExtent()">
 <DES><![CDATA[<h4>GetLayerExtent( table <i>String</i> [ , column <i>String</i> [ , mode <i>Boolean</i>] ] ) : <i>Geometry</i></h4><br>
Return the Envelope corresponding to the Total Extent (bounding box] of some Layer; <br>
 if the Table/Layer only contains a single Geometry column passing the column <br>
 name isn't strictly required. The returned extent will be retrieved from the <br>
 Statistics tables: if the third argument mode is set to TRUEa PESSIMISTIC <br>
 strategy will be applied, i.e. an attempt will be made in order to update the <br>
 Statistics tables before returning the Envelope. otherwise the returned Envelope <br>
 will simply reflect the current values stored into the Statics tables as they are <br>
 (OPTIMISTIC strategy, adopted by default).  NULL will be returned if any error occurs <br>
 or if the required table isn't a Layer. ]]></DES>
</FUNC>

<FUNC caption="CreateTopologyTables" code="CreateTopologyTables()">
 <DES><![CDATA[<h4>CreateTopologyTables( SRID <i>Integer</i> , dims : <i>String</i> ) : <i>Integer</i>   <br>
 CreateTopologyTables( prefix <i>String</i> , SRID <i>Integer</i> , dims : <i>String</i> ) : <i>Integer</i></h4><br>
"Creates a set of Topology tables  SRID argument is mandatory dims argument must be <br>
 'XY' or 'XYZ': 2 or 3 are valid aliases the optional argument prefix can <br>
 be used to support more Topology sets on the same DB: if omitted a ""topo_"" <br>
 prefix will be assumed by default. ]]></DES>
</FUNC>

<FUNC caption="CreateRasterCoveragesTable" code="CreateRasterCoveragesTable()">
 <DES><![CDATA[<h4>CreateRasterCoveragesTable( <i>void</i> ) : <i>Integer</i></h4><br>
Creates the raster_coverages table required by RasterLite-2   <br>
 the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure). ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="33- MetaCatalog" code="">
<DES>SQL functions supporting the MetaCatalog and related Statistics</DES>
<FUNC caption="CreateMetaCatalogTables" code="CreateMetaCatalogTables()">
 <DES><![CDATA[<h4>CreateMetaCatalogTables( transaction <i>Integer</i> ) : <i>Integer</i></h4><br>
Creates both splite_metacatalog and splite_metacatalog_statistics tables; <br>
 splite_metacatalog will be populated so to describe every table/column <br>
 currently defined within the DB. if the first argument transaction is set to <br>
 TRUE the whole operation will be handled as a single Transaction (faster): <br>
 the default setting is transaction=FALSE (slower, but safer). the return type <br>
 is Integer, with a return value of 1 for TRUE or 0 for FALSE. ]]></DES>
</FUNC>

<FUNC caption="UpdateMetaCatalogStatistics" code="UpdateMetaCatalogStatistics()">
 <DES><![CDATA[<h4>UpdateMetaCatalogStatistics( transaction <i>Integer</i> , table_name <i>String</i> , column_name <i>String</i> ) : <i>Integer</i>  <br>
 UpdateMetaCatalogStatistics( transaction <i>Integer</i> , master_table <i>String</i> , table_name <i>String</i> , column_name <i>String</i> ) : <i>Integer</i></h4><br>
Updates the splite_metacatalog_statistics table by computing the statistic summary for the <br>
 required table/column. if the first argument transaction is set to TRUE the <br>
 whole operation will be handled as a single Transaction (faster): the default <br>
 setting is transaction=FALSE (slower, but safer).   the first form (using three <br>
 arguments) will simply attempt to update the statistic summary for a single <br>
 table/column as identified by their names: a matching row is expected to be found <br>
 in splite_metacatalog.   the second form (using four arguments) allows to update <br>
 the statistic summary for many table/columns in a single pass. in this case <br>
 master_table should identify an existing table: table_name and column_name should <br>
 identify two columns belonging to this tables. the statistic summary for every <br>
 table/columns fetched from the master table will then be updated: any mismatching <br>
 table/column will be simply ignored.   the return type is Integer, with a return <br>
 value of 1 for TRUE or 0 for FALSE ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="34- SLD/SE Styled Layers" code="">
<DES>SQL functions supporting SLD/SE Styled Layers</DES>
<FUNC caption="CreateStylingTables" code="CreateStylingTables()">
 <DES><![CDATA[<h4>CreateStylingTables() : <i>Integer</i>   <br>
 CreateStylingTables( relaxed <i>Integer</i> ) : <i>Integer</i></h4><br>
Creates a set of tables supporting SLD/SE Styled Layers.  <br>
 if the optional argument relaxed is specified (any value), then a relaxed <br>
 version of the validating Triggers will be installed.  the return type is <br>
 Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): <br>
 -1 will be returned on invalid arguments.   <br>
 Please note: will implicitly invoke CreateRasterCoverages() if the <br>
 raster_coverages table has not yet been created. ]]></DES>
</FUNC>

<FUNC caption="RegisterExternalGraphic" code="RegisterExternalGraphic()">
 <DES><![CDATA[<h4>RegisterExternalGraphic( xlink_href <i>String</i> , resource <i>BLOB</i> ) : <i>Integer</i>   <br>
 RegisterExternalGraphic( xlink_href <i>String</i> , resource <i>BLOB</i> , title <i>String</i> , abstract <i>String</i> , file_name <i>String</i> ) : <i>Integer</i></h4><br>
Inserts (or updates) an External Graphic Resource.  xlink_href uniquely identifies each Resource (Primary Key). <br>
 resource is expected to be a BLOB containing an image/gif, image/png, <br>
 image/jpeg or image/svg+xml payload. the optional arguments title, <br>
 abstract and file_name could be eventually specified for better human readability.  <br>
 the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE <br>
 (failure): -1 will be returned on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="RegisterVectorStyledLayer" code="RegisterVectorStyledLayer()">
 <DES><![CDATA[<h4>RegisterVectorStyledLayer( f_table_name <i>String</i> , f_geometry_column <i>String</i> , style <i>BLOB</i> ) : <i>Integer</i>  <br>
 RegisterVectorStyledLayer( f_table_name <i>String</i> , f_geometry_column <i>String</i> , style_id <i>Integer</i> , style <i>BLOB</i> ) : <i>Integer</i></h4><br>
Inserts (or updates) a Vector Styled Layer definition.  f_table_name and f_geometry_column must <br>
 identify an existing Vector Layer. style is expected to be an XmlBLOB <br>
 containing a valid SLD/SE Style of the Vector type. If CreatedStylingTables() <br>
 was invoked without specifying the relaxed option this XmlBLOB is expected to <br>
 have successfully passed a formal XML Schema Validation. The same Vector Layer <br>
 could eventually support more than a single Style; in this case the optional <br>
 argument style_id can be explicitly set in order to identify an individual Style. <br>
 If no style_id argument is specified then a new Styled Layer will be created, and the <br>
 style_id value will be automatically set so to ensure univocity.  the return type is <br>
 Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): <br>
 -1 will be returned on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="RegisterRasterStyledLayer" code="RegisterRasterStyledLayer()">
 <DES><![CDATA[<h4>RegisterRasterStyledLayer( coverage_name <i>String</i> , style <i>BLOB</i> ) : <i>Integer</i>   <br>
 RegisterRasterStyledLayer( coverage_name <i>String</i> , style_id <i>Integer</i> , style <i>BLOB</i> ) : <i>Integer</i></h4><br>
Inserts (or updates) a Raster Styled Layer definition.  coverage_name must identify <br>
 an existing Raster Layer. style is expected to be an XmlBLOB containing <br>
 a valid SLD/SE Style of the Raster type. If CreatedStylingTables() was invoked <br>
 without specifying the relaxed option this XmlBLOB is expected to have successfully<br>
 passed a formal XML Schema Validation. The same Raster Layer could eventually support<br>
 more than a single Style; in this case the optional argument style_id can be <br>
 explicitly set in order to identify an individual Style. If no style_id argument <br>
 is specified then a new Styled Layer will be created, and the style_id value will <br>
 be automatically set so to ensure univocity.  the return type is Integer, with a<br>
 return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be <br>
 returned on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="RegisterStyledGroup" code="RegisterStyledGroup()">
 <DES><![CDATA[<h4>RegisterStyledGroup( group_name <i>String</i> , f_table_name <i>String</i> , f_geometry_column <i>String</i> [ , paint_order <i>Integer</i> ] ) : <i>Integer</i>  <br>
 RegisterStyledGroup( group_name <i>String</i> , coverage_name <i>String</i> [ , paint_order <i>Integer</i> ] ) : <i>Integer</i></h4><br>
Inserts (or updates) a Styled Group definition.  group_name must <br>
 identify a Styled Group: if the Styled Group doesn't yet exists it will be implicitly <br>
 created. f_table_name and f_geometry_column must identify an existing Vector Layer. <br>
 or alternatively: coverage_name must identify an existing Raster Layer. the optional <br>
 paint_order argument could be used to explicitly reference an already defined group <br>
 item (this implying updating the previous registration) If paint_order is not specified <br>
 or if a negative value is passed then the next available order position will be automatically <br>
 assigned (this always implying inserting a new registration). Please note: the painting <br>
 order will follow the Painter rule, i.e. a lower paint-order value will always be painted <br>
 before painting any higher value.   the return type is Integer, with a return value of 1 for <br>
 TRUE (success) or 0 for FALSE (failure): -1 will be returned on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="SetStyledGroupInfos" code="SetStyledGroupInfos()">
 <DES><![CDATA[<h4>SetStyledGroupInfos( group_name <i>String</i> , title <i>String</i> , abstract <i>String</i> ) : <i>Integer</i></h4><br>
Inserts (or updates) the descriptive infos associated to a Styled Group.  group_name must <br>
 identify a Styled Group: if the Styled Group doesn't yet exists it will be implicitly <br>
 created. title and abstract represent the descriptive infos to be set.  the return type <br>
 is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): <br>
 -1 will be returned on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="RegisterGroupStyle" code="RegisterGroupStyle()">
 <DES><![CDATA[<h4>RegisterGroupStyle( group_name <i>String</i> , style <i>BLOB</i> ) : <i>Integer</i>  <br>
 RegisterGroupStyle( group_name <i>String</i> , style_id <i>Integer</i> , style <i>BLOB</i> ) : <i>Integer</i></h4><br>
Inserts (or updates) a Group Style definition.  group_name must identify <br>
 an existing Styled Group. style is expected to be an XmlBLOB containing a valid SLD Style. <br>
 If CreatedStylingTables() was invoked without specifying the relaxed option this XmlBLOB <br>
 is expected to have successfully passed a formal XML Schema Validation. The same Styled <br>
 Group could eventually support more than a single Style; in this case the optional argument<br>
 style_id can be explicitly set in order to identify an individual Style. If no style_id <br>
 argument is specified then a new Style will be created, and the style_id value will be <br>
 automatically set so to ensure univocity.  the return type is Integer, with a return value <br>
 of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be returned on invalid arguments. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="35- ISO Metadata" code="">
<DES>SQL functions supporting ISO Metadata</DES>
<FUNC caption="CreateIsoMetadataTables" code="CreateIsoMetadataTables()">
 <DES><![CDATA[<h4>CreateIsoMetadataTables() : <i>Integer</i>   <br>
 CreateIsoMetadataTables( relaxed <i>Integer</i> ) : <i>Integer</i></h4><br>
Creates a set of tables supporting ISO Metadata.  if the optional argument <br>
 relaxed is specified (any value), then a relaxed version of the validating <br>
 Triggers will be installed.  the return type is Integer, with a return value of 1 for TRUE <br>
 (success) or 0 for FALSE (failure): -1 will be returned on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="RegisterIsoMetadata" code="RegisterIsoMetadata()">
 <DES><![CDATA[<h4>RegisterIsoMetadata( scope <i>String</i> , metadata <i>BLOB</i> ) : <i>Integer</i> <br>
 RegisterIsoMetadata( scope <i>String</i> , metadata <i>BLOB</i> , id <i>Integer</i> ) : <i>Integer</i> <br>
 RegisterIsoMetadata( scope <i>String</i> , metadata <i>BLOB</i> , fileIdentifier <i>String</i> ) : <i>Integer</i></h4><br>
Inserts (or updates) an ISO Metadata definition.  scope can be one of undefined,<br>
 fieldSession, collectionSession, series, dataset, featureType, feature, <br>
 attributeType, attribute, tile, model, catalogue, schema, taxonomy, software, <br>
 service, collectionHardware, nonGeographicDataset, dimensionGroup. metadata is <br>
 expected to be a valid XmlBLOB storing some IsoMetadata payload. the first form <br>
 (two arguments only) always performs an INSERT; if one the optional arguments id or <br>
 fileIdentifier an UPDATE could be eventually performed if a corresponding metadata <br>
 row is already defined.  the return type is Integer, with a return value of 1 for TRUE <br>
 (success) or 0 for FALSE (failure): -1 will be returned on invalid arguments. ]]></DES>
</FUNC>

<FUNC caption="GetIsoMetadataId" code="GetIsoMetadataId()">
 <DES><![CDATA[<h4>GetIsoMetadataId( fileIdentifier <i>String</i> ) : <i>Integer</i></h4><br>
Return the unique id corresponding to the ISO Metadata definition identified by fileIdentifier.   <br>
 If no corresponding ISO Metadata definition exists, this function will always<br>
 return ZERO; -1 will be returned for invalid arguments. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="36- FDO/OGR compatibility" code="">
<DES>SQL functions implementing FDO/OGR compatibility</DES>
<FUNC caption="CheckSpatialMetaData" code="CheckSpatialMetaData()">
 <DES><![CDATA[<h4>CheckSpatialMetaData( <i>void</i> ) : <i>Integer</i></h4><br>
Checks the Spatial Metadata type, then returning: 0 - if the geometry_columns or <br>
 spatial_ref_sys table does not exists, or if their actual layout doesn't <br>
 corresponds to any known implementation 1 - if both tables exist, and <br>
 their layout is the one previously used by SpatiaLite legacy (older versions<br>
 including 3.1.0 any earlier) 2 - if both tables exist, and their layout is <br>
 the one used by FDO/OGR 3 - if both tables exist, and their layout is the one <br>
 currently used by SpatiaLite (4.0.0 or any subsequent version) ]]></DES>
</FUNC>
<FUNC caption="AutoFDOStart" code="AutoFDOStart()">
 <DES><![CDATA[<h4>AutoFDOStart( <i>void</i> ) : <i>Integer</i></h4><br>
This function will inspect the Spatial Metadata, then automatically creating/refreshing a Virtual <br>
DFDO wrapper for each FDO/OGR geometry table   the return type is Integer [how many Virtual <br>
DFDO tables have been created] ]]></DES>
</FUNC>

<FUNC caption="AutoFDOStop" code="AutoFDOStop()">
 <DES><![CDATA[<h4>AutoFDOStop( <i>void</i> ) : <i>Integer</i></h4><br>
This function will inspect the Spatial Metadata, then automatically destroying any <br>
 VirtualFDO wrapper found   the return type is Integer [how many <br>
 VirtualFDO tables have been destroyed] ]]></DES>
</FUNC>

<FUNC caption="InitFDOSpatialMetaData" code="InitFDOSpatialMetaData()">
 <DES><![CDATA[<h4>InitFDOSpatialMetaData( <i>void</i> ) : <i>Integer</i></h4><br>
Creates the geometry_columns and spatial_ref_sys metadata tables <br>
 the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE   <br>
 Please note: Spatial Metadata created using this function will have the <br>
 FDO/OGR layout, and not the standard SpatiaLite layout ]]></DES>
</FUNC>

<FUNC caption="AddFDOGeometryColumn" code="AddFDOGeometryColumn()">
 <DES><![CDATA[<h4>AddFDOGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> , geom_type <i>Integer</i> , dimension <i>Integer</i>, geometry_format <i>String</i> ) : <i>Integer</i></h4><br>
Creates a new geometry column updating the FDO/OGR Spatial Metadata tables   <br>
 geom_type has to be one of the followings: <br>
 1 POINT 2 LINESTRING 3 POLYGON 4 MULTIPOINT 5 MULTILINESTRING <br>
 6 MULTIPOLYGON 7 GEOMETRYCOLLECTION <br>
 dimension may be 2, 3 or 4, accordingly to OGR/FDO specs <br>
 geometry_format has to be one of the followings: 'WBT' 'WKT' 'FGF'  <br>
 the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE ]]></DES>
</FUNC>

<FUNC caption="RecoverFDOGeometryColumn" code="RecoverFDOGeometryColumn()">
 <DES><![CDATA[<h4>RecoverFDOGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> , geom_type <i>String</i> , dimension <i>Integer</i>, geometry_format <i>String</i> ) : <i>Integer</i></h4><br>
Validates an existing ordinary column in order to possibly transform it in a <br>
 real geometry column, thus updating the FDO/OGR Spatial Metadata tables   <br>
 the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE ]]></DES>
</FUNC>

<FUNC caption="DiscardFDOGeometryColumn" code="DiscardFDOGeometryColumn()">
 <DES><![CDATA[<h4>DiscardFDOGeometryColumn( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></h4><br>
Removes a geometry column from FDO/OGR Spatial MetaData tables the column itself <br>
 still continues to exist untouched as an ordinary column   <br>
 the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE. ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="37- OGC GeoPackage" code="">
<DES> SQL functions implementing OGC GeoPackage compatibility</DES>
<FUNC caption="CheckGeoPackageMetaData" code="CheckGeoPackageMetaData()">
 <DES><![CDATA[<h4>CheckGeoPackageMetaData( <i>void</i> ) : <i>Integer</i></h4><br>
This function will inspect the DB layout checking if it corresponds to the GPKG <br>
 own style   the return type is Integer, with a return value of 1 for TRUE, 0 for FALSE ]]></DES>
</FUNC>

<FUNC caption="AutoGPKGStart" code="AutoGPKGStart()">
 <DES><![CDATA[<h4>AutoGPKGStart( <i>void</i> ) : <i>Integer</i></h4><br>
This function will inspect the DB layout, then automatically creating/refreshing <br>
 a VirtualGPKG wrapper for each GPKG geometry table   the return type is Integer <br>
 [how many VirtualGPKG tables have been created] ]]></DES>
</FUNC>

<FUNC caption="AutoGPKGStop" code="AutoGPKGStop()">
 <DES><![CDATA[<h4>AutoGPKGStop( <i>void</i> ) : <i>Integer</i></h4><br>
This function will inspect the DB layout, then automatically destroying any <br>
 VirtualGPKG wrapper found   the return type is Integer <br>
 [how many VirtualGPKG tables have been destroyed] ]]></DES>
</FUNC>

<FUNC caption="gpkgCreateBaseTables" code="gpkgCreateBaseTables()">
 <DES><![CDATA[<h4>gpkgCreateBaseTables( <i>void</i> ) : <i>void</i></h4><br>
"This function will create base tables for an ""empty"" GeoPackage. ]]></DES>
</FUNC>

<FUNC caption="gpkgInsertEpsgSRID" code="gpkgInsertEpsgSRID()">
 <DES><![CDATA[<h4>gpkgInsertEpsgSRID( srid <i>Integer</i> ) : <i>void</i></h4><br>
This function will add a spatial reference system entry for the specified EPSG <br>
 identifier; it is an error to try to add the entry if it already exists   <br>
 returns nothing on success, raises exception on error ]]></DES>
</FUNC>

<FUNC caption="gpkgCreateTilesTable" code="gpkgCreateTilesTable()">
 <DES><![CDATA[<h4>gpkgCreateTilesTable( tile_table_name <i>String</i> , srid <i>Integer</i> , min_x <i>Double precision</i> , min_y <i>Double precision</i> , max_x <i>Double precision</i> , max_y <i>Double precision</i> ) : <i>void</i></h4><br>
This function will create a new (empty) Tiles table and the triggers for that table; <br>
 It also adds in the matching entries into gpkg_contents and gpkg_tile_matrix_set. <br>
 This function assumes usual tile conventions, including that the tiles are power-of-two-zoom. <br>
 returns nothing on success, raises exception on error ]]></DES>
</FUNC>

<FUNC caption="gpkgCreateTilesZoomLevel" code="gpkgCreateTilesZoomLevel()">
 <DES><![CDATA[<h4>gpkgCreateTilesZoomLevel( tile_table_name <i>String</i>, zoom_level <i>Integer</i> , extent_width <i>Double precision</i> , extent_height <i>Double precision</i> ) : <i>void</i></h4><br>
This function will add a zoom level for the specified table. This function assumes usual tile conventions, <br>
 including that the tiles are power-of-two-zoom, 256x256 pixels, <br>
 1 tile at the top level (zoom level 0).   <br>
 returns nothing on success, raises exception on error ]]></DES>
</FUNC>

<FUNC caption="gpkgAddTileTriggers" code="gpkgAddTileTriggers()">
 <DES><![CDATA[<h4>gpkgAddTileTriggers( tile_table_name <i>String</i> ) : <i>void</i></h4><br>
This function will add Geopackage tile table triggers for the named table.   <br>
 returns nothing on success, raises exception on error ]]></DES>
</FUNC>

<FUNC caption="gpkgGetNormalZoom" code="gpkgGetNormalZoom()">
 <DES><![CDATA[<h4>gpkgGetNormalZoom( tile_table_name <i>String</i> , inverted_zoom_level <i>Integer</i> ) : <i>Integer</i></h4><br>
This function will return the normal integer zoom level for data stored in the specified table. <br>
 Note that this function can also be used to convert from a normal <br>
 zoom level to an inverted zoom level - this conversion is symmetric.  <br>
 Raises a SQL exception if inverted zoom level is outside the range of<br>
 tile_matrix_metadata table normal zoom levels defined for the tile_table ]]></DES>
</FUNC>

<FUNC caption="gpkgGetNormalRow" code="gpkgGetNormalRow()">
 <DES><![CDATA[<h4>gpkgGetNormalRow( tile_table_name <i>String</i> , normal_zoom_level <i>Integer</i> , inverted_row_number <i>Integer</i> ) : <i>Integer</i></h4><br>
This function will return the normal integer row number for the specified table, <br>
 normal zoom level and inverted row number. Note that this function can <br>
 also be used to convert from a normal row number to an inverted row number<br>
 - this conversion is symmetric.   Raises a SQL exception if no zoom level<br>
 row record in tile_matrix_metadata ]]></DES>
</FUNC>

<FUNC caption="gpkgGetImageType" code="gpkgGetImageType()">
 <DES><![CDATA[<h4>gpkgGetImageType( image <i>BLOB</i> ) : <i>String</i></h4><br>
"This function will return the image type (as a string) of the blob argument, or ""unknown""<br>
 if the image type is not one of the PNG, JPEG, TIFF or WebP format types that <br>
 are supported in GeoPackage. The result will be one of: ]]></DES>
</FUNC>

<FUNC caption="gpkgAddGeometryColumn" code="gpkgAddGeometryColumn()">
 <DES><![CDATA[<h4>gpkgAddGeometryColumn( table_name <i>String</i>, geometry_column_name <i>String</i> , geometry_type <i>String</i> , with_z <i>Integer</i> , with_m <i>Integer</i> , srs_id <i>Integer</i> ) : <i>void</i></h4><br>
Adds a geometry column to the specified table:  geometry_type is a normal WKT name:  ""GEOMETRY" ]]></DES>
</FUNC>

<FUNC caption="gpkgAddGeometryTriggers" code="gpkgAddGeometryTriggers()">
 <DES><![CDATA[<h4>gpkgAddGeometryTriggers( table_name <i>String</i> , geometry_column_name <i>String</i> ) : <i>void</i></h4><br>
This function will add Geopackage geometry table triggers for the named table.   <br>
 returns nothing on success, raises exception on error ]]></DES>
</FUNC>

<FUNC caption="gpkgAddSpatialIndex" code="gpkgAddSpatialIndex()">
 <DES><![CDATA[<h4>gpkgAddSpatialIndex( table_name <i>String</i> , geometry_column_name <i>String</i> ) : <i>void</i></h4><br>
This function will add Geopackage Spatial Index support for the named table.   <br>
 returns nothing on success, raises exception on error ]]></DES>
</FUNC>

<FUNC caption="gpkgMakePoint" code="gpkgMakePoint()">
 <DES><![CDATA[<h4>gpkgMakePoint</i> (x <i>Double precision</i> , y <i>Double precision</i> ) : <i>GPKG BLOB Geometry</i>   <br>
 gpkgMakePoint (x <i>Double precision</i> , y <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG BLOB Geometry</i></h4><br>
This function will create a GeoPackage geometry POINT.   <br>
 Raises a SQL exception on error ]]></DES>
</FUNC>

<FUNC caption="gpkgMakePointZ" code="gpkgMakePointZ()">
 <DES><![CDATA[<h4>gpkgMakePointZ (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> ) : <i>GPKG BLOB Geometry</i>   <br>
 gpkgMakePointZ (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG BLOB Geometry</i></h4><br>
This function will create a GeoPackage geometry POINT Z.  <br>
 Raises a SQL exception on error ]]></DES>
</FUNC>

<FUNC caption="gpkgMakePointM" code="gpkgMakePointM()">
 <DES><![CDATA[<h4>gpkgMakePointM (x <i>Double precision</i> , y <i>Double precision</i> , m <i>Double precision</i> ) : <i>GPKG BLOB Geometry</i>  <br>
 gpkgMakePointM (x <i>Double precision</i> , y <i>Double precision</i> , m <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG BLOB Geometry</i></h4><br>
This function will create a GeoPackage geometry POINT M.  <br>
 Raises a SQL exception on error ]]></DES>
</FUNC>

<FUNC caption="gpkgMakePointZM" code="gpkgMakePointZM()">
 <DES><![CDATA[<h4>gpkgMakePointZM (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , m <i>Double precision</i> ) : <i>GPKG BLOB Geometry</i>   <br>
 gpkgMakePointZM (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , m <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG BLOB Geometry</i></h4><br>
This function will create a GeoPackage geometry POINT ZM.   Raises a SQL exception on error ]]></DES>
</FUNC>

<FUNC caption="IsValidGPB" code="IsValidGPB()">
 <DES><![CDATA[<h4>IsValidGPB( geom <i>BLOB</i> ) : <i>Integer</i></h4><br>
This function will inspect a BLOB then checking if it really corresponds to a GPKG own Geometry  <br>
 the return type is Integer, with a return value of 1 for TRUE, 0 for FALSE ]]></DES>
</FUNC>

<FUNC caption="AsGPB" code="AsGPB()">
 <DES><![CDATA[<h4>AsGPB( geom <i>BLOB encoded Geometry</i> ) : <i>GPKG BLOB Geometry</i></h4><br>
This function will convert a SpatiaLite geometry blob into a GeoPackage format geometry blob.  <br>
 Will return NULL if any error is encountered ]]></DES>
</FUNC>

<FUNC caption="GeomFromGPB" code="GeomFromGPB()">
 <DES><![CDATA[<h4>GeomFromGPB( geom <i>GPKG BLOB Geometry</i> ) : <i>BLOB encoded Geometry</i></h4><br>
This function will convert a GeoPackage format geometry blob into a SpatiaLite geometry blob. <br>
 Will return NULL if any error is encountered ]]></DES>
</FUNC>

<FUNC caption="CastAutomagic" code="CastAutomagic()">
 <DES><![CDATA[<h4>CastAutomagic( geom <i>BLOB</i> ) : <i>BLOB encoded Geometry</i></h4><br>
This function will indifferently accept on input:  a SpatiaLite own BLOB Geometry a GPKG own BLOB<br>
 Geometry then returning a SpatiaLite own BLOB geometry.   <br>
 Will return NULL if any error is encountered or on invalid / mismatching argument ]]></DES>
</FUNC>

<FUNC caption="GPKG_IsAssignable" code="GPKG_IsAssignable()">
 <DES><![CDATA[<h4>GPKG_IsAssignable( expected_type_name <i>String</i> , actual_type_name <i>String</i> ) : <i>Integer</i></h4><br>
This function will check if expected_type is the same or is a super-type of<br>
 actual_type; this function is required by the standard implementation <br>
 of GPKG Geometry validation Triggers.   the return type is Integer, <br>
 with a return value of 1 for TRUE, 0 for FALSE ]]></DES>
</FUNC>


</GROUP>
<GROUP caption="38- SQL for MbrCache" code="">
<DES>SQL functions for MbrCache-based queries</DES>
<FUNC caption="FilterMbrWithin" code="FilterMbrWithin()">
 <DES><![CDATA[<h4>FilterMbrWithin( x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> )</h4><br>
Retrieves from an MbrCache any entity whose MBR falls within the <br>
 rectangle identified by extreme points x1 y1 and x2 y2. ]]></DES>
</FUNC>

<FUNC caption="FilterMbrContains" code="FilterMbrContains()">
 <DES><![CDATA[<h4>FilterMbrContains( x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> )</h4><br>
Retrieves from an MbrCache any entity whose MBR contains the <br>
 rectangle identified by extreme points x1 y1 and x2 y2. ]]></DES>
</FUNC>

<FUNC caption="FilterMbrIntersects" code="FilterMbrIntersects()">
 <DES><![CDATA[<h4>FilterMbrIntersects( x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> )</h4><br>
Retrieves from an MbrCache any entity whose MBR intersects the <br>
 rectangle identified by extreme points x1 y1 and x2 y2. ]]></DES>
</FUNC>

<FUNC caption="BuildMbrFilter" code="BuildMbrFilter()">
 <DES><![CDATA[<h4>BuildMbrFilter( x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> )</h4><br>
Creates an MBR identified by extreme points x1 y1 and x2 y2   <br>
 This fuction is used internally by triggers related to MbrCache <br>
 management, and is not intended for any other usage ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="39- SQL for R*Tree" code="">
<DES>SQL functions for R*Tree-based queries (Geometry Callbacks)</DES>
<FUNC caption="RTreeIntersects" code="RTreeIntersects()">
 <DES><![CDATA[<h4>RTreeIntersects( x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> )</h4><br>
Retrieves from an R*Tree Spatial Index any entity whose MBR intersect the <br>
 rectangle identified by extreme points x1 y1 and x2 y2. ]]></DES>
</FUNC>

<FUNC caption="RTreeWithin" code="RTreeWithin()">
 <DES><![CDATA[<h4>RTreeWithin( x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> )</h4><br>
Deprecated function Still maintained so to avoid backward compatibility issues, <br>
 but now simply is an alias-name for RTreeIntersects ]]></DES>
</FUNC>

<FUNC caption="RTreeContains" code="RTreeContains()">
 <DES><![CDATA[<h4>RTreeContains( x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> )</h4><br>
Deprecated function Still maintained so to avoid backward compatibility issues, <br>
 but now simply is an alias-name for RTreeIntersects ]]></DES>
</FUNC>

<FUNC caption="RTreeDistWithin" code="RTreeDistWithin()">
 <DES><![CDATA[<h4>RTreeDistWithin( x <i>Double precision</i> , y <i>Double precision</i> , radius <i>Double precision</i> )</h4><br>
Retrieves from an R*Tree Spatial Index any entity whose MBR intersect <br>
 the square circumscribed on the given circle (x y center, radius). ]]></DES>
</FUNC>
</GROUP>
<GROUP caption="40- SQL for XmlBLOBs" code="">
<DES>SQL functions supporting XmlBLOB</DES>
<FUNC caption="XB_Create" code="XB_Create()">
 <DES><![CDATA[<h4>XB_Create( xmlPayload <i>BLOB</i> ) : <i>XmlBLOB</i>   <br>
 XB_Create( xmlPayload <i>BLOB</i> , compressed <i>Boolean</i> ) : <i>XmlBLOB</i>  <br>
 XB_Create( xmlPayload <i>BLOB</i> , compressed <i>Boolean</i> , schemaURI <i>Text</i> ) : <i>XmlBLOB</i>   <br>
 XB_Create( xmlPayload <i>BLOB</i> , compressed <i>Boolean</i> , internalSchemaURI <i>Boolean</i> ) : <i>XmlBLOB</i></h4><br>
Construct an XmlBLOB object starting from an XmlDocument. If compressed is set to TRUE <br>
 the XmlBlob object will be compressed (default setting). If schemaURI <br>
 is specified then the XmlDocument will be validated against the given <br>
 Schema (default setting is skipping any XML validation). If internalSchemaURI <br>
 is set (any value), then the XmlDocument will be validated againt the <br>
 Schema URI internally defined within the XmlDocument itse
 (if any).  NULL will be returned for not well-formed XmlDocuments, or when <br>
 XML validation is required but XmlDocument fails to pass validation for any reason. ]]></DES>
</FUNC>

<FUNC caption="XB_GetPayload" code="XB_GetPayload()">
 <DES><![CDATA[<h4>XB_GetPayload( xmlObject <i>XmlBLOB</i> [ , indent <i>Integer</i> ] ) : <i>BLOB</i></h4><br>
Extracts a generic BLOB from an XmlBLOB object, exactly corresponding to the original <br>
 XmlDocument and fully preserving the original character encoding. <br>
 If the optional argument indent is set to some positive value then the <br>
 returned XmlDocument will be nicely formatted and properly indented by the <br>
 required factor; ZERO will cause the whole XmlDocument to be returned as a single line. <br>
 (default setting is negative indenting, i.e. not reformatting at all).   <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object). ]]></DES>
</FUNC>

<FUNC caption="XB_GetDocument" code="XB_GetDocument()">
 <DES><![CDATA[<h4>XB_GetDocument( xmlObject <i>XmlBLOB</i> [ , indent <i>Integer</i> ] ) : <i>String</i></h4><br>
Extracts an XmlDocument from an XmlBLOB object; the returned XmlDocument will always be <br>
 UTF-8 encoded (TEXT), irrespectively from the original internal encoding <br>
 declaration. If the optional argument indent is set to some positive value <br>
 then the returned XmlDocument will be nicely formatted and properly indented by <br>
 the required factor; ZERO will cause the whole XmlDocument to be returned as a <br>
 single line. (default setting is negative indenting, i.e. not reformatting at all).   <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object). ]]></DES>
</FUNC>

<FUNC caption="XB_SchemaValidate" code="XB_SchemaValidate()">
 <DES><![CDATA[<h4>XB_SchemaValidate( xmlObject <i>XmlBLOB</i> , schemaURI <i>Text</i> [ , compressed <i>Boolean</i> ] ) : <i>XmlBLOB</i> <br>
 XB_SchemaValidate( xmlObject <i>XmlBLOB</i> , internalSchemaURI <i>Boolean</i> [ , compressed <i>Boolean</i> ] ) : <i>XmlBLOB</i></h4><br>
Construct an XML validated XmlBLOB object starting from an XmlDocument. If compressed is <br>
 set to TRUE the XmlBlob object will be compressed (default setting). <br>
 If schemaURI is specified then the XmlDocument will be validated against the <br>
 given Schema (default setting is skipping any XML validation). If internalSchemaURI <br>
 is set (any value), then the XmlDocument will be validated againt the Schema URI <br>
 internally defined within the XmlDocument itself (if any).  <br>
 NULL will be returned if the input XmlBLOB fails to pass validation for any reason. ]]></DES>
</FUNC>

<FUNC caption="XB_Compress" code="XB_Compress()">
 <DES><![CDATA[<h4>XB_Compress( xmlObject <i>XmlBLOB</i> ) : <i>XmlBLOB</i></h4><br>
A new compressed XmlBLOB object will be returned. If the input XmlBLOB is already compressed <br>
 this one is a harmless no-op.   <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object). ]]></DES>
</FUNC>

<FUNC caption="XB_Uncompress" code="XB_Uncompress()">
 <DES><![CDATA[<h4>XB_Uncompress( xmlObject <i>XmlBLOB</i> ) : <i>XmlBLOB</i></h4><br>
A new uncompressed XmlBLOB object will be returned. If the input XmlBLOB is already uncompressed <br>
 this one is a harmless no-op.   <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object). ]]></DES>
</FUNC>

<FUNC caption="XB_IsValid" code="XB_IsValid()">
 <DES><![CDATA[<h4>XB_IsValid( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments. ]]></DES>
</FUNC>

<FUNC caption="XB_IsCompressed" code="XB_IsCompressed()">
 <DES><![CDATA[<h4>XB_IsCompressed( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments. ]]></DES>
</FUNC>

<FUNC caption="XB_IsSchemaValidated" code="XB_IsSchemaValidated()">
 <DES><![CDATA[<h4>XB_IsSchemaValidated( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments. ]]></DES>
</FUNC>

<FUNC caption="XB_IsIsoMetadata" code="XB_IsIsoMetadata()">
 <DES><![CDATA[<h4>XB_IsIsoMetadata( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments. ]]></DES>
</FUNC>

<FUNC caption="XB_IsSldSeVectorStyle" code="XB_IsSldSeVectorStyle()">
 <DES><![CDATA[<h4>XB_IsSldSeVectorStyle( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments. ]]></DES>
</FUNC>

<FUNC caption="XB_IsSldSeRasterStyle" code="XB_IsSldSeRasterStyle()">
 <DES><![CDATA[<h4>XB_IsSldSeRasterStyle( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments. ]]></DES>
</FUNC>

<FUNC caption="XB_IsSvg" code="XB_IsSvg()">
 <DES><![CDATA[<h4>XB_IsSvg( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments. ]]></DES>
</FUNC>

<FUNC caption="XB_GetDocumentSize" code="XB_GetDocumentSize()">
 <DES><![CDATA[<h4>XB_GetDocumentSize( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></h4><br>
Will return the size in bytes of the corresponding uncompressed XmlDocument.   <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object). ]]></DES>
</FUNC>

<FUNC caption="XB_GetEncoding" code="XB_GetEncoding()">
 <DES><![CDATA[<h4>XB_GetEncoding( xmlObject <i>XmlBLOB</i> ) : <i>String</i></h4><br>
Will return the character encoding internally declared by the XmlDocument corresponding to the input XmlBLOB.   <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object), or when the XmlDocument doesn't explicitly declares any encoding. ]]></DES>
</FUNC>

<FUNC caption="XB_GetSchemaURI" code="XB_GetSchemaURI()">
 <DES><![CDATA[<h4>XB_GetSchemaURI( xmlObject <i>XmlBLOB</i> ) : <i>String</i></h4><br>
Will return the Schema URI effectively used to validate an XmlBLOB.   <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object), or when the XmlBLOB isn't validated. ]]></DES>
</FUNC>

<FUNC caption="XB_GetInternalSchemaURI" code="XB_GetInternalSchemaURI()">
 <DES><![CDATA[<h4>XB_GetInternalSchemaURI( xmlPayload <i>BLOB</i> ) : <i>String</i></h4><br>
Will return the Schema URI internally declared by the input XmlDocument <br>
 (xsi:noNamespeceSchemaLocation or xsi:schemaLocation).  <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object), <br>
 or when the XmlDocument doesn't declares any Schema at all. ]]></DES>
</FUNC>

<FUNC caption="XB_GetFileId" code="XB_GetFileId()">
 <DES><![CDATA[<h4>XB_GetFileId( xmlObject <i>XmlBLOB</i> ) : <i>String</i></h4><br>
Will return the FileIdentifier defined within the XmlBLOB (if any).   <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object), <br>
 or when no FileIdentifier is defined.   Supported only on ISO Metadata XML Documents. ]]></DES>
</FUNC>

<FUNC caption="XB_SetFileId" code="XB_SetFileId()">
 <DES><![CDATA[<h4>XB_SetFileId( xmlObject <i>XmlBLOB</i> , fileId <i>String</i> ) : <i>XmlBLOB</i></h4><br>
Will return a new XmlBLOB by replacing the FileIdentifier value. The input XmlBLOB is expected <br>
 to be of the ISO Metadata type and must containt an already defined FileIdentifier.  <br>
 NULL will be returned for any invalid input. ]]></DES>
</FUNC>

<FUNC caption="XB_AddFileId" code="XB_AddFileId()">
 <DES><![CDATA[<h4>XB_AddFileId( xmlObject <i>XmlBLOB</i> , fileId <i>String</i> , IdNameSpacePrefix <i>String</i> , IdNameSpaceURI <i>String</i> , CsNameSpacePrefix <i>String</i> , CsNameSpaceURI <i>String</i> ) : <i>XmlBLOB</i></h4><br>
Will return a new XmlBLOB by inserting a FileIdentifier value. The input XmlBLOB is expected <br>
 to be of the ISO Metadata type and must not containt an already <br>
 defined FileIdentifier.   IdNameSpacePrefix and IdNameSpaceURI are expected <br>
 to represent the namespace (if any) corresponding to the <fileIdentifier> <br>
 tag (could be eventually NULL). CsNameSpacePrefix and CsNameSpaceURI are <br>
 expected to represent the namespace (if any) corresponding to the <CharacterString> <br>
 tag (could be eventually NULL).  <br>
 NULL will be returned for any invalid input. ]]></DES>
</FUNC>

<FUNC caption="XB_GetParentId" code="XB_GetParentId()">
 <DES><![CDATA[<h4>XB_GetParentId( xmlObject <i>XmlBLOB</i> ) : <i>String</i></h4><br>
Will return the ParentIdentifier defined within the XmlBLOB (if any).   <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object), <br>
 or when no ParentIdentifier is defined.  <br>
 Supported only on ISO Metadata XML Documents. ]]></DES>
</FUNC>

<FUNC caption="XB_SetParentId" code="XB_SetParentId()">
 <DES><![CDATA[<h4>XB_SetParentId( xmlObject <i>XmlBLOB</i> , parentId <i>String</i> ) : <i>XmlBLOB</i></h4><br>
Will return a new XmlBLOB by replacing the ParentIdentifier value. The input XmlBLOB is <br>
 expected to be of the ISO Metadata type and must containt an already <br>
 defined ParentIdentifier.   <br>
 NULL will be returned for any invalid input. ]]></DES>
</FUNC>

<FUNC caption="XB_AddParentId" code="XB_AddParentId()">
 <DES><![CDATA[<h4>XB_AddParentId( xmlObject <i>XmlBLOB</i> , parentId <i>String</i> , IdNameSpacePrefix <i>String</i> , IdNameSpaceURI <i>String</i> , CsNameSpacePrefix <i>String</i> , CsNameSpaceURI <i>String</i> ) : <i>XmlBLOB</i></h4><br>
Will return a new XmlBLOB by inserting a ParentIdentifier value. The input XmlBLOB is <br>
 expected to be of the ISO Metadata type and must not containt an <br>
 already defined ParentIdentifier.   IdNameSpacePrefix and IdNameSpaceURI <br>
 are expected to represent the namespace (if any) corresponding to the <br>
 <parentIdentifier> tag (could be eventually NULL). CsNameSpacePrefix and <br>
 CsNameSpaceURI are expected to represent the namespace (if any) corresponding <br>
 to the <CharacterString> tag (could be eventually NULL).   <br>
 NULL will be returned for any invalid input. ]]></DES>
</FUNC>

<FUNC caption="XB_GetTitle" code="XB_GetTitle()">
 <DES><![CDATA[<h4>XB_GetTitle( xmlObject <i>XmlBLOB</i> ) : <i>String</i></h4><br>
Will return the Title defined within the XmlBLOB (if any).   
 NULL will be returned for any invalid input (not a valid XmlBLOB object), <br>
 or when no Title is defined.  <br>
 Supported only on ISO Metadata and SLD/SE Styles. ]]></DES>
</FUNC>

<FUNC caption="XB_GetAbstract" code="XB_GetAbstract()">
 <DES><![CDATA[<h4>XB_GetAbstract( xmlObject <i>XmlBLOB</i> ) : <i>String</i></h4><br>
Will return the Abstract defined within the XmlBLOB (if any).  <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object), <br>
 or when no Abstract is defined.  <br>
 Supported only on ISO Metadata and SLD/SE Styles. ]]></DES>
</FUNC>

<FUNC caption="XB_GetGeometry" code="XB_GetGeometry()">
 <DES><![CDATA[<h4>XB_Get<i>Geometry</i>( xmlObject <i>XmlBLOB</i> ) : <i>Geometry</i></h4><br>
Will return the Geometry (Bounding Box) defined within the XmlBLOB (if any).  <br>
 NULL will be returned for any invalid input (not a valid XmlBLOB object), <br>
 or when no Bounding Box is defined.  
 Supported only on ISO Metadata XML Documents. ]]></DES>
</FUNC>

<FUNC caption="XB_GetLastParseError" code="XB_GetLastParseError()">
 <DES><![CDATA[<h4>XB_GetLastParseError( <i>void</i> ) : <i>String</i></h4><br>
Will return the most recent XML parsing error (if any).   <br>
 NULL will be returned if there is no pending parsing error. ]]></DES>
</FUNC>

<FUNC caption="XB_GetLastValidateError" code="XB_GetLastValidateError()">
 <DES><![CDATA[<h4>XB_GetLastValidateError( <i>void</i> ) : <i>String</i></h4><br>
Will return the most recent XML validating error (if any).   <br>
 NULL will be returned if there is no pending validating error. ]]></DES>
</FUNC>

<FUNC caption="XB_IsValidXPathExpression" code="XB_IsValidXPathExpression()">
 <DES><![CDATA[<h4>XB_IsValidXPathExpression( expr <i>Text</i> ) : <i>Integer</i></h4><br>
The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and –1 for UNKNOWN <br>
 corresponding to a function invocation on NULL arguments. ]]></DES>
</FUNC>

<FUNC caption="XB_GetLastXPathError" code="XB_GetLastXPathError()">
 <DES><![CDATA[<h4>XB_GetLastXPathError( <i>void</i> ) : <i>String</i></h4><br>
Will return the most recent XPath error (if any).  <br>
 NULL will be returned if there is no pending XPath error. ]]></DES>
</FUNC>

<FUNC caption="XB_CacheFlush" code="XB_CacheFlush()">
 <DES><![CDATA[<h4>XB_CacheFlush( <i>void</i> ) : <i>Boolean</i></h4><br>
Reset the internal XML Schema cache to its initial empty state. ]]></DES>
</FUNC>

<FUNC caption="XB_LoadXML" code="XB_LoadXML()">
 <DES><![CDATA[<h4>XB_LoadXML( filepath-or-URL <i>String</i> ) : <i>BLOB</i></h4><br>
If filepath-or-URL corresponds to some valid local pathname, and the <br>
 corresponding file (expected to contain a well-formed XML Document) <br>
 can be actually accessed in read mode, then the whole file content will be <br>
 returned as a BLOB value. This function is even able to acces a remote XML <br>
 Document identified by an URL. Otherwise NULL will be returned. Please note: <br>
 SQLite doesn't support BLOB values bigger than SQLITE_MAX_LENGTH (usually, 1 GB).   P<br> ]]></DES>
</FUNC>

<FUNC caption="XB_StoreXML" code="XB_StoreXML()">
 <DES><![CDATA[<h4>XB_StoreXML( XmlObject <i>XmlBLOB</i> , filepath <i>String</i> ) : <i>Integer</i>   XB_StoreXML( XmlObject <i>XmlBLOB</i> , filepath <i>String</i> , indent <i>Integer</i> ) : <i>Integer</i></h4><br>
If XmlObject is of the XmlBLOB-type, and if filepath corresponds to some valid pathname (accessible <br>
 in write/create mode), then the corresponding file will be <br>
 created/overwritten so to contain the corresponding XML Document <br>
 (fully preserving the original character encoding). If the optional <br>
 argument indent is set to some positive value then the returned XmlDocument <br>
 will be nicely formatted and properly indented by the required factor; <br>
 ZERO will cause the whole XmlDocument to be returned as a single line. <br>
 (default setting is negative indenting, i.e. not reformatting at all).   <br>
 The return type is Integer, with a return value of 1 for success, 0 for failure and -1 <br>
 for invalid arguments.    ]]></DES>
</FUNC>
</GROUP>	
</GROUP>
	
<GROUP caption="SpatiaLite Info" code="">
<DES>Queries for checking general build time options of the SpatiaLite extension</DES>
<EXPR caption="Version info" code="select sqlite_version() AS SQLite, spatialite_version() AS SpatiaLite, spatialite_target_cpu() AS T_CPU, proj4_version() AS Proj4, geos_version() AS GEOS, lwgeom_version() AS LWGEOM, libxml2_version() AS LibXML2;">
<DES>Create a report about the SQLite and SpatiaLite versions</DES>
</EXPR>
<EXPR caption="Included components" code="select HasIconv() AS Iconv, HasMathSQL() AS MathSQL, HasGeoCallbacks() AS GeoCallBacks, HasProj() AS Proj4, HasGeos() AS GEOS, HasGeosAdvanced() AS GEOS_Advanced,
HasGeosTrunk() AS GEOS_trunk, HasLwGeom() AS LWGEOM, HasLibXML2() AS LibXML2, HasEpsg() AS EPSG, HasFreeXL() AS FreeXL, HasGeoPackage() AS GPKG;">
<DES>Create a report about which optional components has been built into SpatiaLite extension</DES>
</EXPR>
</GROUP>

	<GROUP caption="SQL" code="textcode1" >
		<EXPR caption="SELECT" code="SELECT" />
		<EXPR caption="FROM" code="FROM" />
		<EXPR caption="WHERE" code="WHERE" />
		<EXPR caption="ORDER BY" code="ORDER BY" />
		<EXPR caption="AND" code="AND" />
		<EXPR caption="AS" code="AS" />
		<EXPR caption="ASC" code="ASC" />
		<EXPR caption="CASE" code="CASE" />
		<EXPR caption="CAST" code="CAST" />
		<EXPR caption="CURRENT_DATE" code="CURRENT_DATE" />
		<EXPR caption="CURRENT_TIME" code="CURRENT_TIME" />
		<EXPR caption="CURRENT_TIMESTAMP" code="CURRENT_TIMESTAMP" />
		<EXPR caption="DESC" code="DESC" />
		<EXPR caption="DISTINCT" code="DISTINCT" />
		<EXPR caption="EXISTS" code="EXISTS" />
		<EXPR caption="GROUP" code="GROUP" />
		<EXPR caption="HAVING" code="HAVING" />
		<EXPR caption="IN" code="IN" />
		<EXPR caption="INNER" code="INNER" />
		<EXPR caption="IS" code="IS" />
		<EXPR caption="ISNULL" code="ISNULL" />
		<EXPR caption="JOIN" code="JOIN" />
		<EXPR caption="NOTNULL" code="NOTNULL" />
		<EXPR caption="NULL" code="NULL" />
		<EXPR caption="OFFSET" code="OFFSET" />
		<EXPR caption="ON" code="ON" />
		<EXPR caption="OR" code="OR" />
		<EXPR caption="OUTER" code="OUTER" />
		<EXPR caption="REGEXP" code="REGEXP" />
		<EXPR caption="UNION" code="UNION" />
	</GROUP>
		<GROUP caption="SQL functions" code="" >
		<FUNC caption="abs" code="abs()" >
			<DES><![CDATA[<h4>abs(<i>X</i>)</h4><br>Return the absolute value of the numeric argument <i>X</i>. Return NULL if <i>X</i> is NULL. Return 0.0<br>if <i>X</i> is not a numeric value.]]></DES>
		</FUNC>
		<FUNC caption="changes" code="changes()" >
			<DES><![CDATA[<h4>changes()</h4><br>Return the number of database rows that were changed or inserted or deleted by the most recently complete<br>SQL. This is a wrapper around the sqlite3_changes() C/C++ function.]]></DES>
		</FUNC>
		<FUNC caption="coalesce" code="coalesce()" >
			<DES><![CDATA[<h4>coalesce(<i>X</i>,<i>Y</i>,...)</h4><br>Return a copy of the first non-NULL argument. If all arguments are NULL then NULL is returned. There<br>must be at least  2 arguments.]]></DES>
		</FUNC>
		<FUNC caption="glob" code="glob()" >
			<DES><![CDATA[<h4>glob(<i>X</i>,<i>Y</i>)</h4><br>This function is used to implement the "<b>Y GLOB X</b>" syntax of SQLite. Note that the X and Y arguments<br>are reversed in the glob() function relative to the infix GLOB operator.]]></DES>
		</FUNC>
		<FUNC caption="ifnull" code="ifnull()" >
			<DES><![CDATA[<h4>ifnull(<i>X</i>,<i>Y</i>)</h4><br>Return a copy of the first non-NULL argument. If both arguments are NULL then NULL is returned. The ifnull()<br>functions and  coalesce() with two arguments are interchangeable.]]></DES>
		</FUNC>
		<FUNC caption="hex" code="hex()" >
			<DES><![CDATA[<h4>hex(<i>X</i>)</h4><br>The argument is interpreted as a BLOB. The result is a hexadecimal rendering of the content of that blob.<br>]]></DES>
		</FUNC>
		<FUNC caption="last_insert_rowid" code="last_insert_rowid()" >
			<DES><![CDATA[<h4>last_insert_rowid()</h4><br>Return the sqlite3_last_insert_rowid() API function.]]></DES>
		</FUNC>
		<FUNC caption="length" code="length()" >
			<DES><![CDATA[<h4>length(<i>X</i>)</h4><br>Return the string length of <i>X</i> in characters if <i>X</i> is a string, or in bytes if <i>X</i> is<br>a blob.]]></DES>
		</FUNC>
		<FUNC caption="like" code="like()" >
			<DES><![CDATA[<h4>like(<i>X</i>,<i>Y</i>, [<i>Z</i>])</h4><br>This function is used to implement the "<b>Y LIKE X [ESCAPE Z]</b>" syntax of SQL. If the optional ESCAPE<br>clause is present, then the user-function is invoked with three arguments. Otherwise, it is invoked<br>with two arguments only. Note that the X and Y parameters are reversed in the like() function relative<br>to the infix LIKE operator depending on whether or not an ESCAPE clause was  specified.]]></DES>
		</FUNC>
		<FUNC caption="load_extension" code="load_extension()" >
			<DES><![CDATA[<h4>load_extension(<i>X</i>,[<i>Y</i>])</h4><br>Load SQLite extensions out of the shared library file named <i>X</i> using the entry point <i>Y</i>.<br>The result is a NULL. If <i>Y</i> is omitted then the default entry point of <b>sqlite3_extension_init</b><br>is used. This function raises an exception if the extension fails to load or initialize correctly. <p>This<br>function will fail if the extension attempts to modify or delete a SQL function or collating sequence.<br>The extension can add new functions or collating sequences, but cannot modify or delete existing functions<br>or collating sequences because those functions and/or collating sequences might be used elsewhere in<br>the currently running SQL statement. To load an extension that changes or deletes functions or collating<br>sequences, use the  sqlite3_load_extension() C-language API.</p>]]></DES>
		</FUNC>
		<FUNC caption="lower" code="lower()" >
			<DES><![CDATA[<h4>lower(<i>X</i>)</h4><br>Return a copy of string <i>X</i> with all ASCII characters converted to lower case. The default built-in<br>lower() function works for ASCII characters only. To do case conversions on non-ASCII characters, load<br>the ICU extension.]]></DES>
		</FUNC>
		<FUNC caption="ltrim" code="ltrim()" >
			<DES><![CDATA[<h4>ltrim(<i>X</i>,[<i>Y</i>)])</h4><br>Return a string formed by removing any and all characters that appear in <i>Y</i> from the left side<br>of <i>X</i>. If the <i>Y</i> argument is omitted, spaces are removed.]]></DES>
		</FUNC>
		<FUNC caption="max" code="max()" >
			<DES><![CDATA[<h4>max(<i>X</i>,<i>Y</i>,...)</h4><br>Return the argument with the maximum value. Or return NULL if any argument is NULL. Note that <b>max()</b><br>is a simple function when it has 2 or more arguments but converts to an aggregate function if given<br>only a single argument.]]></DES>
		</FUNC>
		<FUNC caption="min" code="min()" >
			<DES><![CDATA[<h4>min(<i>X</i>,<i>Y</i>,...)</h4><br>Return the argument with the minimum value.  Note that <b>min()</b> is a simple function when it has<br>2 or more arguments but converts to an aggregate function if given only a single argument.]]></DES>
		</FUNC>
		<FUNC caption="nullif" code="nullif()" >
			<DES><![CDATA[<h4>nullif(<i>X</i>,<i>Y</i>)</h4><br>Return the first argument if the arguments are different,  otherwise return NULL.]]></DES>
		</FUNC>
		<FUNC caption="quote" code="quote()" >
			<DES><![CDATA[<h4>quote(<i>X</i>)</h4><br>This routine returns a string which is the value of its argument suitable for inclusion into another<br>SQL statement. Strings are surrounded by single-quotes with escapes on interior quotes as needed. BLOBs<br>are encoded as hexadecimal literals. SQLite uses this function internally in its implementation of VACUUM<br>command will likely cease to work.]]></DES>
		</FUNC>
		<FUNC caption="random" code="random()" >
			<DES><![CDATA[<h4>random()</h4><br>Return a pseudo-random integer between -9223372036854775808 and +9223372036854775807.]]></DES>
		</FUNC>
		<FUNC caption="randomblob" code="randomblob()" >
			<DES><![CDATA[<h4>randomblob(<i>N</i>)</h4><br>Return an <i>N</i>-byte blob containing pseudo-random bytes. <i>N</i> should be a postive integer. <p>Hint:<br>applications can generate globally unique identifiers using this function together with lower() like<br>this:</p> <blockquote> hex(randomblob(16))<br> lower(hex(randomblob(16))) </blockquote>]]></DES>
		</FUNC>
		<FUNC caption="replace" code="replace()" >
			<DES><![CDATA[<h4>replace(<i>X</i>,<i>Y</i>,<i>Z</i>)</h4><br>Return a string formed by substituting string <i>Z</i> for every occurrance of string <i>Y</i> in string<br><i>X</i>. The BINARY collating sequence is used for comparisons. If <i>Y</i> is an empty string then<br>return <i>X</i> unchanged. If <i>Z</i> is not initially a string, it is cast to a UTF-8 string prior<br>to processing.]]></DES>
		</FUNC>
		<FUNC caption="round" code="round()" >
			<DES><![CDATA[<h4>round(<i>X</i>,[<i>Y</i>])</h4><br>Round off the number <i>X</i> to <i>Y</i> digits to the right of the decimal point. If the <i>Y</i> argument<br>is omitted, 0 is  assumed.]]></DES>
		</FUNC>
		<FUNC caption="rtrim" code="rtrim()" >
			<DES><![CDATA[<h4>rtrim(<i>X</i>,[<i>Y</i>])</h4><br>Return a string formed by removing any and all characters that appear in <i>Y</i> from the right side<br>of <i>X</i>. If the <i>Y</i> argument is omitted, spaces are removed.]]></DES>
		</FUNC>
		<FUNC caption="soundex" code="soundex()" >
			<DES><![CDATA[<h4>soundex(<i>X</i>)</h4><br>Compute the soundex encoding of the string <i>X</i>. The string "?000" is returned if the argument is<br>NULL. This function is omitted from SQLite by default. It is only available the -DSQLITE_SOUNDEX=1 compiler<br>option is used when SQLite is built.]]></DES>
		</FUNC>
		<FUNC caption="sqlite_source_id" code="sqlite_source_id()" >
			<DES><![CDATA[<h4>sqlite_source_id()</h4><br>Return a string that identifies the specific version of the source code that was used to build the SQLite<br>library. The return string begins with the date and time that the source code was checked in and is<br>follows by an SHA1 hash that uniquely identifies the source tree. This function is an SQL wrapper around<br>the sqlite3_sourceid() C interface.]]></DES>
		</FUNC>
		<FUNC caption="sqlite_version" code="sqlite_version()" >
			<DES><![CDATA[<h4>sqlite_version()</h4><br>Return the version string for the SQLite library that is running. Example: "3.5.9". This function is<br>an SQL wrapper around the sqlite3_libversion() C-interface.]]></DES>
		</FUNC>
		<FUNC caption="substr" code="substr()" >
			<DES><![CDATA[<h4>substr(<i>X</i>,<i>Y</i>,[<i>Z</i>])</h4><br>Return a substring of input string <i>X</i> that begins with the <i>Y</i>-th character and which is <i>Z</i><br>characters long. If <i>Z</i> is omitted then all character through the end of the string are returned.<br>The left-most character of <i>X</i> is number 1. If <i>Y</i> is negative the the first character of<br>the substring is found by counting from the right rather than the left. If <i>Z</i> is negative then<br>return the <i>Z</i> characters preceeding the <i>Y</i>-th character. If <i>X</i> is string then characters<br>indices refer to actual UTF-8  characters. If <i>X</i> is a BLOB then the indices refer to bytes.]]></DES>
		</FUNC>
		<FUNC caption="total_changes" code="total_changes()" >
			<DES><![CDATA[<h4>total_changes()</h4><br>Return the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database<br>connection was opened. This function is a wrapper around the sqlite3_total_changes() C/C++ interface.]]></DES>
		</FUNC>
		<FUNC caption="trim" code="trim()" >
			<DES><![CDATA[<h4>trim(<i>X</i>,[<i>Y</i>])</h4><br>Return a string formed by removing any and all characters that appear in <i>Y</i> from both ends of <i>X</i>.<br>If the <i>Y</i> argument is omitted, spaces are removed.]]></DES>
		</FUNC>
		<FUNC caption="typeof" code="typeof()" >
			<DES><![CDATA[<h4>typeof(<i>X</i>)</h4><br>Return the datatype of the expression <i>X</i>. The only  return values are "null", "integer", "real",<br>"text", and "blob".]]></DES>
		</FUNC>
		<FUNC caption="upper" code="upper()" >
			<DES><![CDATA[<h4>upper(<i>X</i>)</h4><br>Return a copy of input string <i>X</i> converted to all upper-case letters. The implementation of this<br>function uses the C library routine <b>toupper()</b> which means it may not work correctly on  non-ASCII<br>UTF-8 strings.]]></DES>
		</FUNC>
		<FUNC caption="zeroblob" code="zeroblob()" >
			<DES><![CDATA[<h4>zeroblob(<i>N</i>)</h4><br>Return a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs<br>can be used to reserve space for a BLOB that is later written using  sqlite3_result_zeroblob() routine<br>from the C/C++ interface.]]></DES>
		</FUNC>
	</GROUP>
	</ROOT>
